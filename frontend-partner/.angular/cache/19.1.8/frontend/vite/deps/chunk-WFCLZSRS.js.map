{
  "version": 3,
  "sources": ["../../../../../../node_modules/@apollo/client/link/http/iterators/async.js", "../../../../../../node_modules/@apollo/client/link/http/iterators/nodeStream.js", "../../../../../../node_modules/@apollo/client/link/http/iterators/promise.js", "../../../../../../node_modules/@apollo/client/link/http/iterators/reader.js", "../../../../../../node_modules/@apollo/client/link/http/responseIterator.js", "../../../../../../node_modules/@apollo/client/errors/index.js", "../../../../../../node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js", "../../../../../../node_modules/@apollo/client/link/http/serializeFetchParameter.js", "../../../../../../node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js", "../../../../../../node_modules/@apollo/client/link/http/checkFetcher.js", "../../../../../../node_modules/@apollo/client/link/http/createSignalIfSupported.js", "../../../../../../node_modules/@apollo/client/link/http/selectURI.js", "../../../../../../node_modules/@apollo/client/link/http/rewriteURIForGET.js", "../../../../../../node_modules/@apollo/client/link/http/createHttpLink.js", "../../../../../../node_modules/@apollo/client/link/http/HttpLink.js", "../../../../../../node_modules/@wry/equality/lib/index.js", "../../../../../../node_modules/@apollo/client/core/equalByQuery.js", "../../../../../../node_modules/@apollo/client/masking/utils.js", "../../../../../../node_modules/@apollo/client/masking/maskDefinition.js", "../../../../../../node_modules/@apollo/client/masking/maskFragment.js", "../../../../../../node_modules/@apollo/client/masking/maskOperation.js", "../../../../../../node_modules/@apollo/client/cache/core/cache.js", "../../../../../../node_modules/@apollo/client/cache/core/types/Cache.js", "../../../../../../node_modules/@apollo/client/cache/core/types/common.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/helpers.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/entityStore.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/object-canon.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/readFromStore.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/reactiveVars.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/key-extractor.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/policies.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/writeToStore.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/inMemoryCache.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/fragmentRegistry.js", "../../../../../../node_modules/@apollo/client/core/networkStatus.js", "../../../../../../node_modules/@apollo/client/core/ObservableQuery.js", "../../../../../../node_modules/@apollo/client/core/QueryInfo.js", "../../../../../../node_modules/@apollo/client/core/QueryManager.js", "../../../../../../node_modules/@apollo/client/core/LocalState.js", "../../../../../../node_modules/@apollo/client/core/ApolloClient.js", "../../../../../../node_modules/graphql-tag/lib/index.js", "../../../../../../node_modules/@apollo/client/core/index.js"],
  "sourcesContent": ["/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/async.ts\n */\nexport default function asyncIterator(source) {\n  var _a;\n  var iterator = source[Symbol.asyncIterator]();\n  return _a = {\n    next: function () {\n      return iterator.next();\n    }\n  }, _a[Symbol.asyncIterator] = function () {\n    return this;\n  }, _a;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/nodeStream.ts\n */\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\nexport default function nodeStreamIterator(stream) {\n  var cleanup = null;\n  var error = null;\n  var done = false;\n  var data = [];\n  var waiting = [];\n  function onData(chunk) {\n    if (error) return;\n    if (waiting.length) {\n      var shiftedArr = waiting.shift();\n      if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n        return shiftedArr[0]({\n          value: chunk,\n          done: false\n        });\n      }\n    }\n    data.push(chunk);\n  }\n  function onError(err) {\n    error = err;\n    var all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[1](err);\n    });\n    !cleanup || cleanup();\n  }\n  function onEnd() {\n    done = true;\n    var all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[0]({\n        value: undefined,\n        done: true\n      });\n    });\n    !cleanup || cleanup();\n  }\n  cleanup = function () {\n    cleanup = null;\n    stream.removeListener(\"data\", onData);\n    stream.removeListener(\"error\", onError);\n    stream.removeListener(\"end\", onEnd);\n    stream.removeListener(\"finish\", onEnd);\n    stream.removeListener(\"close\", onEnd);\n  };\n  stream.on(\"data\", onData);\n  stream.on(\"error\", onError);\n  stream.on(\"end\", onEnd);\n  stream.on(\"finish\", onEnd);\n  stream.on(\"close\", onEnd);\n  function getNext() {\n    return new Promise(function (resolve, reject) {\n      if (error) return reject(error);\n      if (data.length) return resolve({\n        value: data.shift(),\n        done: false\n      });\n      if (done) return resolve({\n        value: undefined,\n        done: true\n      });\n      waiting.push([resolve, reject]);\n    });\n  }\n  var iterator = {\n    next: function () {\n      return getNext();\n    }\n  };\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n  return iterator;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/promise.ts\n */\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\nexport default function promiseIterator(promise) {\n  var resolved = false;\n  var iterator = {\n    next: function () {\n      if (resolved) return Promise.resolve({\n        value: undefined,\n        done: true\n      });\n      resolved = true;\n      return new Promise(function (resolve, reject) {\n        promise.then(function (value) {\n          resolve({\n            value: value,\n            done: false\n          });\n        }).catch(reject);\n      });\n    }\n  };\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n  return iterator;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/reader.ts\n */\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\nexport default function readerIterator(reader) {\n  var iterator = {\n    next: function () {\n      return reader.read();\n    }\n  };\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n  return iterator;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/index.ts\n */\nimport { canUseAsyncIteratorSymbol } from \"../../utilities/index.js\";\nimport asyncIterator from \"./iterators/async.js\";\nimport nodeStreamIterator from \"./iterators/nodeStream.js\";\nimport promiseIterator from \"./iterators/promise.js\";\nimport readerIterator from \"./iterators/reader.js\";\nfunction isNodeResponse(value) {\n  return !!value.body;\n}\nfunction isReadableStream(value) {\n  return !!value.getReader;\n}\nfunction isAsyncIterableIterator(value) {\n  return !!(canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);\n}\nfunction isStreamableBlob(value) {\n  return !!value.stream;\n}\nfunction isBlob(value) {\n  return !!value.arrayBuffer;\n}\nfunction isNodeReadableStream(value) {\n  return !!value.pipe;\n}\nexport function responseIterator(response) {\n  var body = response;\n  if (isNodeResponse(response)) body = response.body;\n  if (isAsyncIterableIterator(body)) return asyncIterator(body);\n  if (isReadableStream(body)) return readerIterator(body.getReader());\n  // this errors without casting to ReadableStream<T>\n  // because Blob.stream() returns a NodeJS ReadableStream\n  if (isStreamableBlob(body)) {\n    return readerIterator(body.stream().getReader());\n  }\n  if (isBlob(body)) return promiseIterator(body.arrayBuffer());\n  if (isNodeReadableStream(body)) return nodeStreamIterator(body);\n  throw new Error(\"Unknown body type for responseIterator. Please pass a streamable response.\");\n}\n", "import { __extends, __spreadArray } from \"tslib\";\nimport \"../utilities/globals/index.js\";\nimport { isNonNullObject } from \"../utilities/index.js\";\n// This Symbol allows us to pass transport-specific errors from the link chain\n// into QueryManager/client internals without risking a naming collision within\n// extensions (which implementers can use as they see fit).\nexport var PROTOCOL_ERRORS_SYMBOL = Symbol();\nexport function graphQLResultHasProtocolErrors(result) {\n  if (result.extensions) {\n    return Array.isArray(result.extensions[PROTOCOL_ERRORS_SYMBOL]);\n  }\n  return false;\n}\nexport function isApolloError(err) {\n  return err.hasOwnProperty(\"graphQLErrors\");\n}\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nvar generateErrorMessage = function (err) {\n  var errors = __spreadArray(__spreadArray(__spreadArray([], err.graphQLErrors, true), err.clientErrors, true), err.protocolErrors, true);\n  if (err.networkError) errors.push(err.networkError);\n  return errors\n  // The rest of the code sometimes unsafely types non-Error objects as GraphQLErrors\n  .map(function (err) {\n    return isNonNullObject(err) && err.message || \"Error message not found.\";\n  }).join(\"\\n\");\n};\nvar ApolloError = /** @class */function (_super) {\n  __extends(ApolloError, _super);\n  // Constructs an instance of ApolloError given serialized GraphQL errors,\n  // client errors, protocol errors or network errors.\n  // Note that one of these has to be a valid\n  // value or the constructed error will be meaningless.\n  function ApolloError(_a) {\n    var graphQLErrors = _a.graphQLErrors,\n      protocolErrors = _a.protocolErrors,\n      clientErrors = _a.clientErrors,\n      networkError = _a.networkError,\n      errorMessage = _a.errorMessage,\n      extraInfo = _a.extraInfo;\n    var _this = _super.call(this, errorMessage) || this;\n    _this.name = \"ApolloError\";\n    _this.graphQLErrors = graphQLErrors || [];\n    _this.protocolErrors = protocolErrors || [];\n    _this.clientErrors = clientErrors || [];\n    _this.networkError = networkError || null;\n    _this.message = errorMessage || generateErrorMessage(_this);\n    _this.extraInfo = extraInfo;\n    _this.cause = __spreadArray(__spreadArray(__spreadArray([networkError], graphQLErrors || [], true), protocolErrors || [], true), clientErrors || [], true).find(function (e) {\n      return !!e;\n    }) || null;\n    // We're not using `Object.setPrototypeOf` here as it isn't fully\n    // supported on Android (see issue #3236).\n    _this.__proto__ = ApolloError.prototype;\n    return _this;\n  }\n  return ApolloError;\n}(Error);\nexport { ApolloError };\n", "import { __assign, __awaiter, __generator } from \"tslib\";\nimport { responseIterator } from \"./responseIterator.js\";\nimport { throwServerError } from \"../utils/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../../errors/index.js\";\nimport { isApolloPayloadResult } from \"../../utilities/common/incrementalResult.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function readMultipartBody(response, nextValue) {\n  return __awaiter(this, void 0, void 0, function () {\n    var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _a, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result, next;\n    var _b, _c;\n    var _d;\n    return __generator(this, function (_e) {\n      switch (_e.label) {\n        case 0:\n          if (TextDecoder === undefined) {\n            throw new Error(\"TextDecoder must be defined in the environment: please import a polyfill.\");\n          }\n          decoder = new TextDecoder(\"utf-8\");\n          contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get(\"content-type\");\n          delimiter = \"boundary=\";\n          boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['\"]/g, \"\").replace(/\\;(.*)/gm, \"\").trim() : \"-\";\n          boundary = \"\\r\\n--\".concat(boundaryVal);\n          buffer = \"\";\n          iterator = responseIterator(response);\n          running = true;\n          _e.label = 1;\n        case 1:\n          if (!running) return [3 /*break*/, 3];\n          return [4 /*yield*/, iterator.next()];\n        case 2:\n          _a = _e.sent(), value = _a.value, done = _a.done;\n          chunk = typeof value === \"string\" ? value : decoder.decode(value);\n          searchFrom = buffer.length - boundary.length + 1;\n          running = !done;\n          buffer += chunk;\n          bi = buffer.indexOf(boundary, searchFrom);\n          while (bi > -1) {\n            message = void 0;\n            _b = [buffer.slice(0, bi), buffer.slice(bi + boundary.length)], message = _b[0], buffer = _b[1];\n            i = message.indexOf(\"\\r\\n\\r\\n\");\n            headers = parseHeaders(message.slice(0, i));\n            contentType_1 = headers[\"content-type\"];\n            if (contentType_1 && contentType_1.toLowerCase().indexOf(\"application/json\") === -1) {\n              throw new Error(\"Unsupported patch content type: application/json is required.\");\n            }\n            body = message.slice(i);\n            if (body) {\n              result = parseJsonBody(response, body);\n              if (Object.keys(result).length > 1 || \"data\" in result || \"incremental\" in result || \"errors\" in result || \"payload\" in result) {\n                if (isApolloPayloadResult(result)) {\n                  next = {};\n                  if (\"payload\" in result) {\n                    if (Object.keys(result).length === 1 && result.payload === null) {\n                      return [2 /*return*/];\n                    }\n                    next = __assign({}, result.payload);\n                  }\n                  if (\"errors\" in result) {\n                    next = __assign(__assign({}, next), {\n                      extensions: __assign(__assign({}, \"extensions\" in next ? next.extensions : null), (_c = {}, _c[PROTOCOL_ERRORS_SYMBOL] = result.errors, _c))\n                    });\n                  }\n                  nextValue(next);\n                } else {\n                  // for the last chunk with only `hasNext: false`\n                  // we don't need to call observer.next as there is no data/errors\n                  nextValue(result);\n                }\n              } else if (\n              // If the chunk contains only a \"hasNext: false\", we can call\n              // observer.complete() immediately.\n              Object.keys(result).length === 1 && \"hasNext\" in result && !result.hasNext) {\n                return [2 /*return*/];\n              }\n            }\n            bi = buffer.indexOf(boundary);\n          }\n          return [3 /*break*/, 1];\n        case 3:\n          return [2 /*return*/];\n      }\n    });\n  });\n}\nexport function parseHeaders(headerText) {\n  var headersInit = {};\n  headerText.split(\"\\n\").forEach(function (line) {\n    var i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      var name_1 = line.slice(0, i).trim().toLowerCase();\n      var value = line.slice(i + 1).trim();\n      headersInit[name_1] = value;\n    }\n  });\n  return headersInit;\n}\nexport function parseJsonBody(response, bodyText) {\n  if (response.status >= 300) {\n    // Network error\n    var getResult = function () {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n    throwServerError(response, getResult(), \"Response not successful: Received status code \".concat(response.status));\n  }\n  try {\n    return JSON.parse(bodyText);\n  } catch (err) {\n    var parseError = err;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\nexport function handleError(err, observer) {\n  // if it is a network error, BUT there is graphql result info fire\n  // the next observer before calling error this gives apollo-client\n  // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n  // pass to UI this should only happen if we *also* have data as\n  // part of the response key per the spec\n  if (err.result && err.result.errors && err.result.data) {\n    // if we don't call next, the UI can only show networkError\n    // because AC didn't get any graphqlErrors this is graphql\n    // execution result info (i.e errors and possibly data) this is\n    // because there is no formal spec how errors should translate to\n    // http status codes. So an auth error (401) could have both data\n    // from a public field, errors from a private field, and a status\n    // of 401\n    // {\n    //  user { // this will have errors\n    //    firstName\n    //  }\n    //  products { // this is public so will have data\n    //    cost\n    //  }\n    // }\n    //\n    // the result of above *could* look like this:\n    // {\n    //   data: { products: [{ cost: \"$10\" }] },\n    //   errors: [{\n    //      message: 'your session has timed out',\n    //      path: []\n    //   }]\n    // }\n    // status code of above would be a 401\n    // in the UI you want to show data where you can, errors as data where you can\n    // and use correct http status codes\n    observer.next(err.result);\n  }\n  observer.error(err);\n}\nexport function parseAndCheckHttpResponse(operations) {\n  return function (response) {\n    return response.text().then(function (bodyText) {\n      return parseJsonBody(response, bodyText);\n    }).then(function (result) {\n      if (!Array.isArray(result) && !hasOwnProperty.call(result, \"data\") && !hasOwnProperty.call(result, \"errors\")) {\n        // Data error\n        throwServerError(response, result, \"Server response was missing for query '\".concat(Array.isArray(operations) ? operations.map(function (op) {\n          return op.operationName;\n        }) : operations.operationName, \"'.\"));\n      }\n      return result;\n    });\n  };\n}\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\nexport var serializeFetchParameter = function (p, label) {\n  var serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e) {\n    var parseError = newInvariantError(42, label, e.message);\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n", "import { __assign, __spreadArray } from \"tslib\";\nimport { print } from \"../../utilities/index.js\";\nvar defaultHttpOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n  preserveHeaderCase: false\n};\nvar defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: \"*/*\",\n  // The content-type header describes the type of the body of the request, and\n  // so it typically only is sent with requests that actually have bodies. One\n  // could imagine that Apollo Client would remove this header when constructing\n  // a GET request (which has no body), but we historically have not done that.\n  // This means that browsers will preflight all Apollo Client requests (even\n  // GET requests). Apollo Server's CSRF prevention feature (introduced in\n  // AS3.7) takes advantage of this fact and does not block requests with this\n  // header. If you want to drop this header from GET requests, then you should\n  // probably replace it with a `apollo-require-preflight` header, or servers\n  // with CSRF prevention enabled might block your GET request. See\n  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf\n  // for more details.\n  \"content-type\": \"application/json\"\n};\nvar defaultOptions = {\n  method: \"POST\"\n};\nexport var fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions\n};\nexport var defaultPrinter = function (ast, printer) {\n  return printer(ast);\n};\nexport function selectHttpOptionsAndBody(operation, fallbackConfig) {\n  var configs = [];\n  for (var _i = 2; _i < arguments.length; _i++) {\n    configs[_i - 2] = arguments[_i];\n  }\n  configs.unshift(fallbackConfig);\n  return selectHttpOptionsAndBodyInternal.apply(void 0, __spreadArray([operation, defaultPrinter], configs, false));\n}\nexport function selectHttpOptionsAndBodyInternal(operation, printer) {\n  var configs = [];\n  for (var _i = 2; _i < arguments.length; _i++) {\n    configs[_i - 2] = arguments[_i];\n  }\n  var options = {};\n  var http = {};\n  configs.forEach(function (config) {\n    options = __assign(__assign(__assign({}, options), config.options), {\n      headers: __assign(__assign({}, options.headers), config.headers)\n    });\n    if (config.credentials) {\n      options.credentials = config.credentials;\n    }\n    http = __assign(__assign({}, http), config.http);\n  });\n  if (options.headers) {\n    options.headers = removeDuplicateHeaders(options.headers, http.preserveHeaderCase);\n  }\n  //The body depends on the http options\n  var operationName = operation.operationName,\n    extensions = operation.extensions,\n    variables = operation.variables,\n    query = operation.query;\n  var body = {\n    operationName: operationName,\n    variables: variables\n  };\n  if (http.includeExtensions) body.extensions = extensions;\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) body.query = printer(query, print);\n  return {\n    options: options,\n    body: body\n  };\n}\n// Remove potential duplicate header names, preserving last (by insertion order).\n// This is done to prevent unintentionally duplicating a header instead of\n// overwriting it (See #8447 and #8449).\nfunction removeDuplicateHeaders(headers, preserveHeaderCase) {\n  // If we're not preserving the case, just remove duplicates w/ normalization.\n  if (!preserveHeaderCase) {\n    var normalizedHeaders_1 = {};\n    Object.keys(Object(headers)).forEach(function (name) {\n      normalizedHeaders_1[name.toLowerCase()] = headers[name];\n    });\n    return normalizedHeaders_1;\n  }\n  // If we are preserving the case, remove duplicates w/ normalization,\n  // preserving the original name.\n  // This allows for non-http-spec-compliant servers that expect intentionally\n  // capitalized header names (See #6741).\n  var headerData = {};\n  Object.keys(Object(headers)).forEach(function (name) {\n    headerData[name.toLowerCase()] = {\n      originalName: name,\n      value: headers[name]\n    };\n  });\n  var normalizedHeaders = {};\n  Object.keys(headerData).forEach(function (name) {\n    normalizedHeaders[headerData[name].originalName] = headerData[name].value;\n  });\n  return normalizedHeaders;\n}\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\nexport var checkFetcher = function (fetcher) {\n  if (!fetcher && typeof fetch === \"undefined\") {\n    throw newInvariantError(40);\n  }\n};\n", "/**\n * @deprecated\n * This is not used internally any more and will be removed in\n * the next major version of Apollo Client.\n */\nexport var createSignalIfSupported = function () {\n  if (typeof AbortController === \"undefined\") return {\n    controller: false,\n    signal: false\n  };\n  var controller = new AbortController();\n  var signal = controller.signal;\n  return {\n    controller: controller,\n    signal: signal\n  };\n};\n", "export var selectURI = function (operation, fallbackURI) {\n  var context = operation.getContext();\n  var contextURI = context.uri;\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === \"function\") {\n    return fallbackURI(operation);\n  } else {\n    return fallbackURI || \"/graphql\";\n  }\n};\n", "import { serializeFetchParameter } from \"./serializeFetchParameter.js\";\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nexport function rewriteURIForGET(chosenURI, body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  var queryParams = [];\n  var addQueryParam = function (key, value) {\n    queryParams.push(\"\".concat(key, \"=\").concat(encodeURIComponent(value)));\n  };\n  if (\"query\" in body) {\n    addQueryParam(\"query\", body.query);\n  }\n  if (body.operationName) {\n    addQueryParam(\"operationName\", body.operationName);\n  }\n  if (body.variables) {\n    var serializedVariables = void 0;\n    try {\n      serializedVariables = serializeFetchParameter(body.variables, \"Variables map\");\n    } catch (parseError) {\n      return {\n        parseError: parseError\n      };\n    }\n    addQueryParam(\"variables\", serializedVariables);\n  }\n  if (body.extensions) {\n    var serializedExtensions = void 0;\n    try {\n      serializedExtensions = serializeFetchParameter(body.extensions, \"Extensions map\");\n    } catch (parseError) {\n      return {\n        parseError: parseError\n      };\n    }\n    addQueryParam(\"extensions\", serializedExtensions);\n  }\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  var fragment = \"\",\n    preFragment = chosenURI;\n  var fragmentStart = chosenURI.indexOf(\"#\");\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  var queryParamsPrefix = preFragment.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n  var newURI = preFragment + queryParamsPrefix + queryParams.join(\"&\") + fragment;\n  return {\n    newURI: newURI\n  };\n}\n", "import { __assign, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { ApolloLink } from \"../core/index.js\";\nimport { Observable, hasDirectives } from \"../../utilities/index.js\";\nimport { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport { selectURI } from \"./selectURI.js\";\nimport { handleError, readMultipartBody, parseAndCheckHttpResponse } from \"./parseAndCheckHttpResponse.js\";\nimport { checkFetcher } from \"./checkFetcher.js\";\nimport { selectHttpOptionsAndBodyInternal, defaultPrinter, fallbackHttpConfig } from \"./selectHttpOptionsAndBody.js\";\nimport { rewriteURIForGET } from \"./rewriteURIForGET.js\";\nimport { fromError, filterOperationVariables } from \"../utils/index.js\";\nimport { maybe, getMainDefinition, removeClientSetsFromDocument } from \"../../utilities/index.js\";\nvar backupFetch = maybe(function () {\n  return fetch;\n});\nexport var createHttpLink = function (linkOptions) {\n  if (linkOptions === void 0) {\n    linkOptions = {};\n  }\n  var _a = linkOptions.uri,\n    uri = _a === void 0 ? \"/graphql\" : _a,\n    // use default global fetch if nothing passed in\n    preferredFetch = linkOptions.fetch,\n    _b = linkOptions.print,\n    print = _b === void 0 ? defaultPrinter : _b,\n    includeExtensions = linkOptions.includeExtensions,\n    preserveHeaderCase = linkOptions.preserveHeaderCase,\n    useGETForQueries = linkOptions.useGETForQueries,\n    _c = linkOptions.includeUnusedVariables,\n    includeUnusedVariables = _c === void 0 ? false : _c,\n    requestOptions = __rest(linkOptions, [\"uri\", \"fetch\", \"print\", \"includeExtensions\", \"preserveHeaderCase\", \"useGETForQueries\", \"includeUnusedVariables\"]);\n  if (globalThis.__DEV__ !== false) {\n    // Make sure at least one of preferredFetch, window.fetch, or backupFetch is\n    // defined, so requests won't fail at runtime.\n    checkFetcher(preferredFetch || backupFetch);\n  }\n  var linkConfig = {\n    http: {\n      includeExtensions: includeExtensions,\n      preserveHeaderCase: preserveHeaderCase\n    },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers\n  };\n  return new ApolloLink(function (operation) {\n    var chosenURI = selectURI(operation, uri);\n    var context = operation.getContext();\n    // `apollographql-client-*` headers are automatically set if a\n    // `clientAwareness` object is found in the context. These headers are\n    // set first, followed by the rest of the headers pulled from\n    // `context.headers`. If desired, `apollographql-client-*` headers set by\n    // the `clientAwareness` object can be overridden by\n    // `apollographql-client-*` headers set in `context.headers`.\n    var clientAwarenessHeaders = {};\n    if (context.clientAwareness) {\n      var _a = context.clientAwareness,\n        name_1 = _a.name,\n        version = _a.version;\n      if (name_1) {\n        clientAwarenessHeaders[\"apollographql-client-name\"] = name_1;\n      }\n      if (version) {\n        clientAwarenessHeaders[\"apollographql-client-version\"] = version;\n      }\n    }\n    var contextHeaders = __assign(__assign({}, clientAwarenessHeaders), context.headers);\n    var contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: contextHeaders\n    };\n    if (hasDirectives([\"client\"], operation.query)) {\n      var transformedQuery = removeClientSetsFromDocument(operation.query);\n      if (!transformedQuery) {\n        return fromError(new Error(\"HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`.\"));\n      }\n      operation.query = transformedQuery;\n    }\n    //uses fallback, link, and then context to build options\n    var _b = selectHttpOptionsAndBodyInternal(operation, print, fallbackHttpConfig, linkConfig, contextConfig),\n      options = _b.options,\n      body = _b.body;\n    if (body.variables && !includeUnusedVariables) {\n      body.variables = filterOperationVariables(body.variables, operation.query);\n    }\n    var controller;\n    if (!options.signal && typeof AbortController !== \"undefined\") {\n      controller = new AbortController();\n      options.signal = controller.signal;\n    }\n    // If requested, set method to GET if there are no mutations.\n    var definitionIsMutation = function (d) {\n      return d.kind === \"OperationDefinition\" && d.operation === \"mutation\";\n    };\n    var definitionIsSubscription = function (d) {\n      return d.kind === \"OperationDefinition\" && d.operation === \"subscription\";\n    };\n    var isSubscription = definitionIsSubscription(getMainDefinition(operation.query));\n    // does not match custom directives beginning with @defer\n    var hasDefer = hasDirectives([\"defer\"], operation.query);\n    if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {\n      options.method = \"GET\";\n    }\n    if (hasDefer || isSubscription) {\n      options.headers = options.headers || {};\n      var acceptHeader = \"multipart/mixed;\";\n      // Omit defer-specific headers if the user attempts to defer a selection\n      // set on a subscription and log a warning.\n      if (isSubscription && hasDefer) {\n        globalThis.__DEV__ !== false && invariant.warn(41);\n      }\n      if (isSubscription) {\n        acceptHeader += \"boundary=graphql;subscriptionSpec=1.0,application/json\";\n      } else if (hasDefer) {\n        acceptHeader += \"deferSpec=20220824,application/json\";\n      }\n      options.headers.accept = acceptHeader;\n    }\n    if (options.method === \"GET\") {\n      var _c = rewriteURIForGET(chosenURI, body),\n        newURI = _c.newURI,\n        parseError = _c.parseError;\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    } else {\n      try {\n        options.body = serializeFetchParameter(body, \"Payload\");\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n    }\n    return new Observable(function (observer) {\n      // Prefer linkOptions.fetch (preferredFetch) if provided, and otherwise\n      // fall back to the *current* global window.fetch function (see issue\n      // #7832), or (if all else fails) the backupFetch function we saved when\n      // this module was first evaluated. This last option protects against the\n      // removal of window.fetch, which is unlikely but not impossible.\n      var currentFetch = preferredFetch || maybe(function () {\n        return fetch;\n      }) || backupFetch;\n      var observerNext = observer.next.bind(observer);\n      currentFetch(chosenURI, options).then(function (response) {\n        var _a;\n        operation.setContext({\n          response: response\n        });\n        var ctype = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.get(\"content-type\");\n        if (ctype !== null && /^multipart\\/mixed/i.test(ctype)) {\n          return readMultipartBody(response, observerNext);\n        } else {\n          return parseAndCheckHttpResponse(operation)(response).then(observerNext);\n        }\n      }).then(function () {\n        controller = undefined;\n        observer.complete();\n      }).catch(function (err) {\n        controller = undefined;\n        handleError(err, observer);\n      });\n      return function () {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n", "import { __extends } from \"tslib\";\nimport { ApolloLink } from \"../core/index.js\";\nimport { createHttpLink } from \"./createHttpLink.js\";\nvar HttpLink = /** @class */function (_super) {\n  __extends(HttpLink, _super);\n  function HttpLink(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _this = _super.call(this, createHttpLink(options).request) || this;\n    _this.options = options;\n    return _this;\n  }\n  return HttpLink;\n}(ApolloLink);\nexport { HttpLink };\n", "const {\n  toString,\n  hasOwnProperty\n} = Object.prototype;\nconst fnToStr = Function.prototype.toString;\nconst previousComparisons = new Map();\n/**\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\n */\nexport function equal(a, b) {\n  try {\n    return check(a, b);\n  } finally {\n    previousComparisons.clear();\n  }\n}\n// Allow default imports as well.\nexport default equal;\nfunction check(a, b) {\n  // If the two values are strictly equal, our job is easy.\n  if (a === b) {\n    return true;\n  }\n  // Object.prototype.toString returns a representation of the runtime type of\n  // the given value that is considerably more precise than typeof.\n  const aTag = toString.call(a);\n  const bTag = toString.call(b);\n  // If the runtime types of a and b are different, they could maybe be equal\n  // under some interpretation of equality, but for simplicity and performance\n  // we just return false instead.\n  if (aTag !== bTag) {\n    return false;\n  }\n  switch (aTag) {\n    case '[object Array]':\n      // Arrays are a lot like other objects, but we can cheaply compare their\n      // lengths as a short-cut before comparing their elements.\n      if (a.length !== b.length) return false;\n    // Fall through to object case...\n    case '[object Object]':\n      {\n        if (previouslyCompared(a, b)) return true;\n        const aKeys = definedKeys(a);\n        const bKeys = definedKeys(b);\n        // If `a` and `b` have a different number of enumerable keys, they\n        // must be different.\n        const keyCount = aKeys.length;\n        if (keyCount !== bKeys.length) return false;\n        // Now make sure they have the same keys.\n        for (let k = 0; k < keyCount; ++k) {\n          if (!hasOwnProperty.call(b, aKeys[k])) {\n            return false;\n          }\n        }\n        // Finally, check deep equality of all child properties.\n        for (let k = 0; k < keyCount; ++k) {\n          const key = aKeys[k];\n          if (!check(a[key], b[key])) {\n            return false;\n          }\n        }\n        return true;\n      }\n    case '[object Error]':\n      return a.name === b.name && a.message === b.message;\n    case '[object Number]':\n      // Handle NaN, which is !== itself.\n      if (a !== a) return b !== b;\n    // Fall through to shared +a === +b case...\n    case '[object Boolean]':\n    case '[object Date]':\n      return +a === +b;\n    case '[object RegExp]':\n    case '[object String]':\n      return a == `${b}`;\n    case '[object Map]':\n    case '[object Set]':\n      {\n        if (a.size !== b.size) return false;\n        if (previouslyCompared(a, b)) return true;\n        const aIterator = a.entries();\n        const isMap = aTag === '[object Map]';\n        while (true) {\n          const info = aIterator.next();\n          if (info.done) break;\n          // If a instanceof Set, aValue === aKey.\n          const [aKey, aValue] = info.value;\n          // So this works the same way for both Set and Map.\n          if (!b.has(aKey)) {\n            return false;\n          }\n          // However, we care about deep equality of values only when dealing\n          // with Map structures.\n          if (isMap && !check(aValue, b.get(aKey))) {\n            return false;\n          }\n        }\n        return true;\n      }\n    case '[object Uint16Array]':\n    case '[object Uint8Array]': // Buffer, in Node.js.\n    case '[object Uint32Array]':\n    case '[object Int32Array]':\n    case '[object Int8Array]':\n    case '[object Int16Array]':\n    case '[object ArrayBuffer]':\n      // DataView doesn't need these conversions, but the equality check is\n      // otherwise the same.\n      a = new Uint8Array(a);\n      b = new Uint8Array(b);\n    // Fall through...\n    case '[object DataView]':\n      {\n        let len = a.byteLength;\n        if (len === b.byteLength) {\n          while (len-- && a[len] === b[len]) {\n            // Keep looping as long as the bytes are equal.\n          }\n        }\n        return len === -1;\n      }\n    case '[object AsyncFunction]':\n    case '[object GeneratorFunction]':\n    case '[object AsyncGeneratorFunction]':\n    case '[object Function]':\n      {\n        const aCode = fnToStr.call(a);\n        if (aCode !== fnToStr.call(b)) {\n          return false;\n        }\n        // We consider non-native functions equal if they have the same code\n        // (native functions require === because their code is censored).\n        // Note that this behavior is not entirely sound, since !== function\n        // objects with the same code can behave differently depending on\n        // their closure scope. However, any function can behave differently\n        // depending on the values of its input arguments (including this)\n        // and its calling context (including its closure scope), even\n        // though the function object is === to itself; and it is entirely\n        // possible for functions that are not === to behave exactly the\n        // same under all conceivable circumstances. Because none of these\n        // factors are statically decidable in JavaScript, JS function\n        // equality is not well-defined. This ambiguity allows us to\n        // consider the best possible heuristic among various imperfect\n        // options, and equating non-native functions that have the same\n        // code has enormous practical benefits, such as when comparing\n        // functions that are repeatedly passed as fresh function\n        // expressions within objects that are otherwise deeply equal. Since\n        // any function created from the same syntactic expression (in the\n        // same code location) will always stringify to the same code\n        // according to fnToStr.call, we can reasonably expect these\n        // repeatedly passed function expressions to have the same code, and\n        // thus behave \"the same\" (with all the caveats mentioned above),\n        // even though the runtime function objects are !== to one another.\n        return !endsWith(aCode, nativeCodeSuffix);\n      }\n  }\n  // Otherwise the values are not equal.\n  return false;\n}\nfunction definedKeys(obj) {\n  // Remember that the second argument to Array.prototype.filter will be\n  // used as `this` within the callback function.\n  return Object.keys(obj).filter(isDefinedKey, obj);\n}\nfunction isDefinedKey(key) {\n  return this[key] !== void 0;\n}\nconst nativeCodeSuffix = \"{ [native code] }\";\nfunction endsWith(full, suffix) {\n  const fromIndex = full.length - suffix.length;\n  return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;\n}\nfunction previouslyCompared(a, b) {\n  // Though cyclic references can make an object graph appear infinite from the\n  // perspective of a depth-first traversal, the graph still contains a finite\n  // number of distinct object references. We use the previousComparisons cache\n  // to avoid comparing the same pair of object references more than once, which\n  // guarantees termination (even if we end up comparing every object in one\n  // graph to every object in the other graph, which is extremely unlikely),\n  // while still allowing weird isomorphic structures (like rings with different\n  // lengths) a chance to pass the equality test.\n  let bSet = previousComparisons.get(a);\n  if (bSet) {\n    // Return true here because we can be sure false will be returned somewhere\n    // else if the objects are not equivalent.\n    if (bSet.has(b)) return true;\n  } else {\n    previousComparisons.set(a, bSet = new Set());\n  }\n  bSet.add(b);\n  return false;\n}\n", "import { __rest } from \"tslib\";\nimport equal from \"@wry/equality\";\nimport { createFragmentMap, getFragmentDefinitions, getFragmentFromSelection, getMainDefinition, isField, resultKeyNameFromField, shouldInclude } from \"../utilities/index.js\";\n// Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\nexport function equalByQuery(query, _a, _b, variables) {\n  var aData = _a.data,\n    aRest = __rest(_a, [\"data\"]);\n  var bData = _b.data,\n    bRest = __rest(_b, [\"data\"]);\n  return equal(aRest, bRest) && equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {\n    fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n    variables: variables\n  });\n}\nfunction equalBySelectionSet(selectionSet, aResult, bResult, context) {\n  if (aResult === bResult) {\n    return true;\n  }\n  var seenSelections = new Set();\n  // Returning true from this Array.prototype.every callback function skips the\n  // current field/subtree. Returning false aborts the entire traversal\n  // immediately, causing equalBySelectionSet to return false.\n  return selectionSet.selections.every(function (selection) {\n    // Avoid re-processing the same selection at the same level of recursion, in\n    // case the same field gets included via multiple indirect fragment spreads.\n    if (seenSelections.has(selection)) return true;\n    seenSelections.add(selection);\n    // Ignore @skip(if: true) and @include(if: false) fields.\n    if (!shouldInclude(selection, context.variables)) return true;\n    // If the field or (named) fragment spread has a @nonreactive directive on\n    // it, we don't care if it's different, so we pretend it's the same.\n    if (selectionHasNonreactiveDirective(selection)) return true;\n    if (isField(selection)) {\n      var resultKey = resultKeyNameFromField(selection);\n      var aResultChild = aResult && aResult[resultKey];\n      var bResultChild = bResult && bResult[resultKey];\n      var childSelectionSet = selection.selectionSet;\n      if (!childSelectionSet) {\n        // These are scalar values, so we can compare them with deep equal\n        // without redoing the main recursive work.\n        return equal(aResultChild, bResultChild);\n      }\n      var aChildIsArray = Array.isArray(aResultChild);\n      var bChildIsArray = Array.isArray(bResultChild);\n      if (aChildIsArray !== bChildIsArray) return false;\n      if (aChildIsArray && bChildIsArray) {\n        var length_1 = aResultChild.length;\n        if (bResultChild.length !== length_1) {\n          return false;\n        }\n        for (var i = 0; i < length_1; ++i) {\n          if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);\n    } else {\n      var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n      if (fragment) {\n        // The fragment might === selection if it's an inline fragment, but\n        // could be !== if it's a named fragment ...spread.\n        if (selectionHasNonreactiveDirective(fragment)) return true;\n        return equalBySelectionSet(fragment.selectionSet,\n        // Notice that we reuse the same aResult and bResult values here,\n        // since the fragment ...spread does not specify a field name, but\n        // consists of multiple fields (within the fragment's selection set)\n        // that should be applied to the current result value(s).\n        aResult, bResult, context);\n      }\n    }\n  });\n}\nfunction selectionHasNonreactiveDirective(selection) {\n  return !!selection.directives && selection.directives.some(directiveIsNonreactive);\n}\nfunction directiveIsNonreactive(dir) {\n  return dir.name.value === \"nonreactive\";\n}\n", "import { Slot } from \"optimism\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { canUseWeakMap, canUseWeakSet } from \"../utilities/index.js\";\nexport var MapImpl = canUseWeakMap ? WeakMap : Map;\nexport var SetImpl = canUseWeakSet ? WeakSet : Set;\n// Contextual slot that allows us to disable accessor warnings on fields when in\n// migrate mode.\n/** @internal */\nexport var disableWarningsSlot = new Slot();\nvar issuedWarning = false;\nexport function warnOnImproperCacheImplementation() {\n  if (!issuedWarning) {\n    issuedWarning = true;\n    globalThis.__DEV__ !== false && invariant.warn(52);\n  }\n}\n", "import { Kind } from \"graphql\";\nimport { getFragmentMaskMode, maybeDeepFreeze, resultKeyNameFromField } from \"../utilities/index.js\";\nimport { disableWarningsSlot } from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nexport function maskDefinition(data, selectionSet, context) {\n  return disableWarningsSlot.withValue(true, function () {\n    var masked = maskSelectionSet(data, selectionSet, context, false);\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n    return masked;\n  });\n}\nfunction getMutableTarget(data, mutableTargets) {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n  var mutableTarget = Array.isArray(data) ? [] : Object.create(null);\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\nfunction maskSelectionSet(data, selectionSet, context, migration, path) {\n  var _a;\n  var knownChanged = context.knownChanged;\n  var memo = getMutableTarget(data, context.mutableTargets);\n  if (Array.isArray(data)) {\n    for (var _i = 0, _b = Array.from(data.entries()); _i < _b.length; _i++) {\n      var _c = _b[_i],\n        index = _c[0],\n        item = _c[1];\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n      var masked = maskSelectionSet(item, selectionSet, context, migration, globalThis.__DEV__ !== false ? \"\".concat(path || \"\", \"[\").concat(index, \"]\") : void 0);\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n      memo[index] = masked;\n    }\n    return knownChanged.has(memo) ? memo : data;\n  }\n  for (var _d = 0, _e = selectionSet.selections; _d < _e.length; _d++) {\n    var selection = _e[_d];\n    var value = void 0;\n    // we later want to add acessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n    if (migration) {\n      knownChanged.add(memo);\n    }\n    if (selection.kind === Kind.FIELD) {\n      var keyName = resultKeyNameFromField(selection);\n      var childSelectionSet = selection.selectionSet;\n      value = memo[keyName] || data[keyName];\n      if (value === void 0) {\n        continue;\n      }\n      if (childSelectionSet && value !== null) {\n        var masked = maskSelectionSet(data[keyName], childSelectionSet, context, migration, globalThis.__DEV__ !== false ? \"\".concat(path || \"\", \".\").concat(keyName) : void 0);\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n      if (!(globalThis.__DEV__ !== false)) {\n        memo[keyName] = value;\n      }\n      if (globalThis.__DEV__ !== false) {\n        if (migration && keyName !== \"__typename\" &&\n        // either the field is not present in the memo object\n        // or it has a `get` descriptor, not a `value` descriptor\n        // => it is a warning accessor and we can overwrite it\n        // with another accessor\n        !((_a = Object.getOwnPropertyDescriptor(memo, keyName)) === null || _a === void 0 ? void 0 : _a.value)) {\n          Object.defineProperty(memo, keyName, getAccessorWarningDescriptor(keyName, value, path || \"\", context.operationName, context.operationType));\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n    if (selection.kind === Kind.INLINE_FRAGMENT && (!selection.typeCondition || context.cache.fragmentMatches(selection, data.__typename))) {\n      value = maskSelectionSet(data, selection.selectionSet, context, migration, path);\n    }\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      var fragmentName = selection.name.value;\n      var fragment = context.fragmentMap[fragmentName] || (context.fragmentMap[fragmentName] = context.cache.lookupFragment(fragmentName));\n      invariant(fragment, 47, fragmentName);\n      var mode = getFragmentMaskMode(selection);\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(data, fragment.selectionSet, context, mode === \"migrate\", path);\n      }\n    }\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  }\n  // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n  return knownChanged.has(memo) ? memo : data;\n}\nfunction getAccessorWarningDescriptor(fieldName, value, path, operationName, operationType) {\n  var getValue = function () {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n    globalThis.__DEV__ !== false && invariant.warn(48, operationName ? \"\".concat(operationType, \" '\").concat(operationName, \"'\") : \"anonymous \".concat(operationType), \"\".concat(path, \".\").concat(fieldName).replace(/^\\./, \"\"));\n    getValue = function () {\n      return value;\n    };\n    return value;\n  };\n  return {\n    get: function () {\n      return getValue();\n    },\n    set: function (newValue) {\n      getValue = function () {\n        return newValue;\n      };\n    },\n    enumerable: true,\n    configurable: true\n  };\n}\n", "import { Kind } from \"graphql\";\nimport { MapImpl, SetImpl, warnOnImproperCacheImplementation } from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport equal from \"@wry/equality\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport { createFragmentMap, getFragmentDefinitions } from \"../utilities/index.js\";\n/** @internal */\nexport function maskFragment(data, document, cache, fragmentName) {\n  if (!cache.fragmentMatches) {\n    if (globalThis.__DEV__ !== false) {\n      warnOnImproperCacheImplementation();\n    }\n    return data;\n  }\n  var fragments = document.definitions.filter(function (node) {\n    return node.kind === Kind.FRAGMENT_DEFINITION;\n  });\n  if (typeof fragmentName === \"undefined\") {\n    invariant(fragments.length === 1, 49, fragments.length);\n    fragmentName = fragments[0].name.value;\n  }\n  var fragment = fragments.find(function (fragment) {\n    return fragment.name.value === fragmentName;\n  });\n  invariant(!!fragment, 50, fragmentName);\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n  if (equal(data, {})) {\n    // Return early and skip the masking algorithm if we don't have any data\n    // yet. This can happen when cache.diff returns an empty object which is\n    // used from watchFragment.\n    return data;\n  }\n  return maskDefinition(data, fragment.selectionSet, {\n    operationType: \"fragment\",\n    operationName: fragment.name.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache: cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl()\n  });\n}\n", "import { invariant } from \"../utilities/globals/index.js\";\nimport { createFragmentMap, getFragmentDefinitions, getOperationDefinition } from \"../utilities/index.js\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport { MapImpl, SetImpl, warnOnImproperCacheImplementation } from \"./utils.js\";\n/** @internal */\nexport function maskOperation(data, document, cache) {\n  var _a;\n  if (!cache.fragmentMatches) {\n    if (globalThis.__DEV__ !== false) {\n      warnOnImproperCacheImplementation();\n    }\n    return data;\n  }\n  var definition = getOperationDefinition(document);\n  invariant(definition, 51);\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n  return maskDefinition(data, definition.selectionSet, {\n    operationType: definition.operation,\n    operationName: (_a = definition.name) === null || _a === void 0 ? void 0 : _a.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache: cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl()\n  });\n}\n", "import { __assign, __rest } from \"tslib\";\nimport { wrap } from \"optimism\";\nimport { Observable, cacheSizes, getFragmentDefinition, getFragmentQueryDocument, mergeDeepArray } from \"../../utilities/index.js\";\nimport { WeakCache } from \"@wry/caches\";\nimport { getApolloCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\nimport { equalByQuery } from \"../../core/equalByQuery.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { maskFragment } from \"../../masking/index.js\";\nvar ApolloCache = /** @class */function () {\n  function ApolloCache() {\n    this.assumeImmutableResults = false;\n    // Make sure we compute the same (===) fragment query document every\n    // time we receive the same fragment in readFragment.\n    this.getFragmentDoc = wrap(getFragmentQueryDocument, {\n      max: cacheSizes[\"cache.fragmentQueryDocuments\"] || 1000 /* defaultCacheSizes[\"cache.fragmentQueryDocuments\"] */,\n      cache: WeakCache\n    });\n  }\n  // Function used to lookup a fragment when a fragment definition is not part\n  // of the GraphQL document. This is useful for caches, such as InMemoryCache,\n  // that register fragments ahead of time so they can be referenced by name.\n  ApolloCache.prototype.lookupFragment = function (fragmentName) {\n    return null;\n  };\n  // Transactional API\n  // The batch method is intended to replace/subsume both performTransaction\n  // and recordOptimisticTransaction, but performTransaction came first, so we\n  // provide a default batch implementation that's just another way of calling\n  // performTransaction. Subclasses of ApolloCache (such as InMemoryCache) can\n  // override the batch method to do more interesting things with its options.\n  ApolloCache.prototype.batch = function (options) {\n    var _this = this;\n    var optimisticId = typeof options.optimistic === \"string\" ? options.optimistic : options.optimistic === false ? null : void 0;\n    var updateResult;\n    this.performTransaction(function () {\n      return updateResult = options.update(_this);\n    }, optimisticId);\n    return updateResult;\n  };\n  ApolloCache.prototype.recordOptimisticTransaction = function (transaction, optimisticId) {\n    this.performTransaction(transaction, optimisticId);\n  };\n  // Optional API\n  // Called once per input document, allowing the cache to make static changes\n  // to the query, such as adding __typename fields.\n  ApolloCache.prototype.transformDocument = function (document) {\n    return document;\n  };\n  // Called before each ApolloLink request, allowing the cache to make dynamic\n  // changes to the query, such as filling in missing fragment definitions.\n  ApolloCache.prototype.transformForLink = function (document) {\n    return document;\n  };\n  ApolloCache.prototype.identify = function (object) {\n    return;\n  };\n  ApolloCache.prototype.gc = function () {\n    return [];\n  };\n  ApolloCache.prototype.modify = function (options) {\n    return false;\n  };\n  // DataProxy API\n  ApolloCache.prototype.readQuery = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = !!options.optimistic;\n    }\n    return this.read(__assign(__assign({}, options), {\n      rootId: options.id || \"ROOT_QUERY\",\n      optimistic: optimistic\n    }));\n  };\n  /** {@inheritDoc @apollo/client!ApolloClient#watchFragment:member(1)} */\n  ApolloCache.prototype.watchFragment = function (options) {\n    var _this = this;\n    var fragment = options.fragment,\n      fragmentName = options.fragmentName,\n      from = options.from,\n      _a = options.optimistic,\n      optimistic = _a === void 0 ? true : _a,\n      otherOptions = __rest(options, [\"fragment\", \"fragmentName\", \"from\", \"optimistic\"]);\n    var query = this.getFragmentDoc(fragment, fragmentName);\n    // While our TypeScript types do not allow for `undefined` as a valid\n    // `from`, its possible `useFragment` gives us an `undefined` since it\n    // calls` cache.identify` and provides that value to `from`. We are\n    // adding this fix here however to ensure those using plain JavaScript\n    // and using `cache.identify` themselves will avoid seeing the obscure\n    // warning.\n    var id = typeof from === \"undefined\" || typeof from === \"string\" ? from : this.identify(from);\n    var dataMasking = !!options[Symbol.for(\"apollo.dataMasking\")];\n    if (globalThis.__DEV__ !== false) {\n      var actualFragmentName = fragmentName || getFragmentDefinition(fragment).name.value;\n      if (!id) {\n        globalThis.__DEV__ !== false && invariant.warn(1, actualFragmentName);\n      }\n    }\n    var diffOptions = __assign(__assign({}, otherOptions), {\n      returnPartialData: true,\n      id: id,\n      query: query,\n      optimistic: optimistic\n    });\n    var latestDiff;\n    return new Observable(function (observer) {\n      return _this.watch(__assign(__assign({}, diffOptions), {\n        immediate: true,\n        callback: function (diff) {\n          var data = dataMasking ? maskFragment(diff.result, fragment, _this, fragmentName) : diff.result;\n          if (\n          // Always ensure we deliver the first result\n          latestDiff && equalByQuery(query, {\n            data: latestDiff.result\n          }, {\n            data: data\n          },\n          // TODO: Fix the type on WatchFragmentOptions so that TVars\n          // extends OperationVariables\n          options.variables)) {\n            return;\n          }\n          var result = {\n            data: data,\n            complete: !!diff.complete\n          };\n          if (diff.missing) {\n            result.missing = mergeDeepArray(diff.missing.map(function (error) {\n              return error.missing;\n            }));\n          }\n          latestDiff = __assign(__assign({}, diff), {\n            result: data\n          });\n          observer.next(result);\n        }\n      }));\n    });\n  };\n  ApolloCache.prototype.readFragment = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = !!options.optimistic;\n    }\n    return this.read(__assign(__assign({}, options), {\n      query: this.getFragmentDoc(options.fragment, options.fragmentName),\n      rootId: options.id,\n      optimistic: optimistic\n    }));\n  };\n  ApolloCache.prototype.writeQuery = function (_a) {\n    var id = _a.id,\n      data = _a.data,\n      options = __rest(_a, [\"id\", \"data\"]);\n    return this.write(Object.assign(options, {\n      dataId: id || \"ROOT_QUERY\",\n      result: data\n    }));\n  };\n  ApolloCache.prototype.writeFragment = function (_a) {\n    var id = _a.id,\n      data = _a.data,\n      fragment = _a.fragment,\n      fragmentName = _a.fragmentName,\n      options = __rest(_a, [\"id\", \"data\", \"fragment\", \"fragmentName\"]);\n    return this.write(Object.assign(options, {\n      query: this.getFragmentDoc(fragment, fragmentName),\n      dataId: id,\n      result: data\n    }));\n  };\n  ApolloCache.prototype.updateQuery = function (options, update) {\n    return this.batch({\n      update: function (cache) {\n        var value = cache.readQuery(options);\n        var data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeQuery(__assign(__assign({}, options), {\n          data: data\n        }));\n        return data;\n      }\n    });\n  };\n  ApolloCache.prototype.updateFragment = function (options, update) {\n    return this.batch({\n      update: function (cache) {\n        var value = cache.readFragment(options);\n        var data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeFragment(__assign(__assign({}, options), {\n          data: data\n        }));\n        return data;\n      }\n    });\n  };\n  return ApolloCache;\n}();\nexport { ApolloCache };\nif (globalThis.__DEV__ !== false) {\n  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;\n}\n", "export var Cache;\n(function (Cache) {})(Cache || (Cache = {}));\n", "import { __extends } from \"tslib\";\nvar MissingFieldError = /** @class */function (_super) {\n  __extends(MissingFieldError, _super);\n  function MissingFieldError(message, path, query, variables) {\n    var _a;\n    // 'Error' breaks prototype chain here\n    var _this = _super.call(this, message) || this;\n    _this.message = message;\n    _this.path = path;\n    _this.query = query;\n    _this.variables = variables;\n    if (Array.isArray(_this.path)) {\n      _this.missing = _this.message;\n      for (var i = _this.path.length - 1; i >= 0; --i) {\n        _this.missing = (_a = {}, _a[_this.path[i]] = _this.missing, _a);\n      }\n    } else {\n      _this.missing = _this.path;\n    }\n    // We're not using `Object.setPrototypeOf` here as it isn't fully supported\n    // on Android (see issue #3236).\n    _this.__proto__ = MissingFieldError.prototype;\n    return _this;\n  }\n  return MissingFieldError;\n}(Error);\nexport { MissingFieldError };\n", "import { isReference, isField, DeepMerger, resultKeyNameFromField, shouldInclude, isNonNullObject, compact, createFragmentMap, getFragmentDefinitions, isArray } from \"../../utilities/index.js\";\nexport var hasOwn = Object.prototype.hasOwnProperty;\nexport function isNullish(value) {\n  return value === null || value === void 0;\n}\nexport { isArray };\nexport function defaultDataIdFromObject(_a, context) {\n  var __typename = _a.__typename,\n    id = _a.id,\n    _id = _a._id;\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject = !isNullish(id) ? {\n        id: id\n      } : !isNullish(_id) ? {\n        _id: _id\n      } : void 0;\n    }\n    // If there is no object.id, fall back to object._id.\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n    if (!isNullish(id)) {\n      return \"\".concat(__typename, \":\").concat(typeof id === \"number\" || typeof id === \"string\" ? id : JSON.stringify(id));\n    }\n  }\n}\nvar defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  // Thanks to the shouldCanonizeResults helper, this should be the only line\n  // you have to change to reenable canonization by default in the future.\n  canonizeResults: false\n};\nexport function normalizeConfig(config) {\n  return compact(defaultConfig, config);\n}\nexport function shouldCanonizeResults(config) {\n  var value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\nexport function getTypenameFromStoreObject(store, objectOrReference) {\n  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, \"__typename\") : objectOrReference && objectOrReference.__typename;\n}\nexport var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nexport function fieldNameFromStoreName(storeFieldName) {\n  var match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\nexport function selectionSetMatchesResult(selectionSet, result, variables) {\n  if (isNonNullObject(result)) {\n    return isArray(result) ? result.every(function (item) {\n      return selectionSetMatchesResult(selectionSet, item, variables);\n    }) : selectionSet.selections.every(function (field) {\n      if (isField(field) && shouldInclude(field, variables)) {\n        var key = resultKeyNameFromField(field);\n        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));\n      }\n      // If the selection has been skipped with @skip(true) or\n      // @include(false), it should not count against the matching. If\n      // the selection is not a field, it must be a fragment (inline or\n      // named). We will determine if selectionSetMatchesResult for that\n      // fragment when we get to it, so for now we return true.\n      return true;\n    });\n  }\n  return false;\n}\nexport function storeValueIsStoreObject(value) {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\nexport function extractFragmentContext(document, fragments) {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  var fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap: fragmentMap,\n    lookupFragment: function (name) {\n      var def = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    }\n  };\n}\n", "import { __assign, __extends, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { dep } from \"optimism\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport { isReference, makeReference, DeepMerger, maybeDeepFreeze, canUseWeakMap, isNonNullObject } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName } from \"./helpers.js\";\nvar DELETE = Object.create(null);\nvar delModifier = function () {\n  return DELETE;\n};\nvar INVALIDATE = Object.create(null);\nvar EntityStore = /** @class */function () {\n  function EntityStore(policies, group) {\n    var _this = this;\n    this.policies = policies;\n    this.group = group;\n    this.data = Object.create(null);\n    // Maps root entity IDs to the number of times they have been retained, minus\n    // the number of times they have been released. Retained entities keep other\n    // entities they reference (even indirectly) from being garbage collected.\n    this.rootIds = Object.create(null);\n    // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].\n    this.refs = Object.create(null);\n    // Bound function that can be passed around to provide easy access to fields\n    // of Reference objects as well as ordinary objects.\n    this.getFieldValue = function (objectOrReference, storeFieldName) {\n      return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);\n    };\n    // Returns true for non-normalized StoreObjects and non-dangling\n    // References, indicating that readField(name, objOrRef) has a chance of\n    // working. Useful for filtering out dangling references from lists.\n    this.canRead = function (objOrRef) {\n      return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === \"object\";\n    };\n    // Bound function that converts an id or an object with a __typename and\n    // primary key fields to a Reference object. If called with a Reference object,\n    // that same Reference object is returned. Pass true for mergeIntoStore to persist\n    // an object into the store.\n    this.toReference = function (objOrIdOrRef, mergeIntoStore) {\n      if (typeof objOrIdOrRef === \"string\") {\n        return makeReference(objOrIdOrRef);\n      }\n      if (isReference(objOrIdOrRef)) {\n        return objOrIdOrRef;\n      }\n      var id = _this.policies.identify(objOrIdOrRef)[0];\n      if (id) {\n        var ref = makeReference(id);\n        if (mergeIntoStore) {\n          _this.merge(id, objOrIdOrRef);\n        }\n        return ref;\n      }\n    };\n  }\n  // Although the EntityStore class is abstract, it contains concrete\n  // implementations of the various NormalizedCache interface methods that\n  // are inherited by the Root and Layer subclasses.\n  EntityStore.prototype.toObject = function () {\n    return __assign({}, this.data);\n  };\n  EntityStore.prototype.has = function (dataId) {\n    return this.lookup(dataId, true) !== void 0;\n  };\n  EntityStore.prototype.get = function (dataId, fieldName) {\n    this.group.depend(dataId, fieldName);\n    if (hasOwn.call(this.data, dataId)) {\n      var storeObject = this.data[dataId];\n      if (storeObject && hasOwn.call(storeObject, fieldName)) {\n        return storeObject[fieldName];\n      }\n    }\n    if (fieldName === \"__typename\" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {\n      return this.policies.rootTypenamesById[dataId];\n    }\n    if (this instanceof Layer) {\n      return this.parent.get(dataId, fieldName);\n    }\n  };\n  EntityStore.prototype.lookup = function (dataId, dependOnExistence) {\n    // The has method (above) calls lookup with dependOnExistence = true, so\n    // that it can later be invalidated when we add or remove a StoreObject for\n    // this dataId. Any consumer who cares about the contents of the StoreObject\n    // should not rely on this dependency, since the contents could change\n    // without the object being added or removed.\n    if (dependOnExistence) this.group.depend(dataId, \"__exists\");\n    if (hasOwn.call(this.data, dataId)) {\n      return this.data[dataId];\n    }\n    if (this instanceof Layer) {\n      return this.parent.lookup(dataId, dependOnExistence);\n    }\n    if (this.policies.rootTypenamesById[dataId]) {\n      return Object.create(null);\n    }\n  };\n  EntityStore.prototype.merge = function (older, newer) {\n    var _this = this;\n    var dataId;\n    // Convert unexpected references to ID strings.\n    if (isReference(older)) older = older.__ref;\n    if (isReference(newer)) newer = newer.__ref;\n    var existing = typeof older === \"string\" ? this.lookup(dataId = older) : older;\n    var incoming = typeof newer === \"string\" ? this.lookup(dataId = newer) : newer;\n    // If newer was a string ID, but that ID was not defined in this store,\n    // then there are no fields to be merged, so we're done.\n    if (!incoming) return;\n    invariant(typeof dataId === \"string\", 2);\n    var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);\n    // Even if merged === existing, existing may have come from a lower\n    // layer, so we always need to set this.data[dataId] on this level.\n    this.data[dataId] = merged;\n    if (merged !== existing) {\n      delete this.refs[dataId];\n      if (this.group.caching) {\n        var fieldsToDirty_1 = Object.create(null);\n        // If we added a new StoreObject where there was previously none, dirty\n        // anything that depended on the existence of this dataId, such as the\n        // EntityStore#has method.\n        if (!existing) fieldsToDirty_1.__exists = 1;\n        // Now invalidate dependents who called getFieldValue for any fields\n        // that are changing as a result of this merge.\n        Object.keys(incoming).forEach(function (storeFieldName) {\n          if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {\n            // Always dirty the full storeFieldName, which may include\n            // serialized arguments following the fieldName prefix.\n            fieldsToDirty_1[storeFieldName] = 1;\n            // Also dirty fieldNameFromStoreName(storeFieldName) if it's\n            // different from storeFieldName and this field does not have\n            // keyArgs configured, because that means the cache can't make\n            // any assumptions about how field values with the same field\n            // name but different arguments might be interrelated, so it\n            // must err on the side of invalidating all field values that\n            // share the same short fieldName, regardless of arguments.\n            var fieldName = fieldNameFromStoreName(storeFieldName);\n            if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {\n              fieldsToDirty_1[fieldName] = 1;\n            }\n            // If merged[storeFieldName] has become undefined, and this is the\n            // Root layer, actually delete the property from the merged object,\n            // which is guaranteed to have been created fresh in this method.\n            if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {\n              delete merged[storeFieldName];\n            }\n          }\n        });\n        if (fieldsToDirty_1.__typename && !(existing && existing.__typename) &&\n        // Since we return default root __typename strings\n        // automatically from store.get, we don't need to dirty the\n        // ROOT_QUERY.__typename field if merged.__typename is equal\n        // to the default string (usually \"Query\").\n        this.policies.rootTypenamesById[dataId] === merged.__typename) {\n          delete fieldsToDirty_1.__typename;\n        }\n        Object.keys(fieldsToDirty_1).forEach(function (fieldName) {\n          return _this.group.dirty(dataId, fieldName);\n        });\n      }\n    }\n  };\n  EntityStore.prototype.modify = function (dataId, fields) {\n    var _this = this;\n    var storeObject = this.lookup(dataId);\n    if (storeObject) {\n      var changedFields_1 = Object.create(null);\n      var needToMerge_1 = false;\n      var allDeleted_1 = true;\n      var sharedDetails_1 = {\n        DELETE: DELETE,\n        INVALIDATE: INVALIDATE,\n        isReference: isReference,\n        toReference: this.toReference,\n        canRead: this.canRead,\n        readField: function (fieldNameOrOptions, from) {\n          return _this.policies.readField(typeof fieldNameOrOptions === \"string\" ? {\n            fieldName: fieldNameOrOptions,\n            from: from || makeReference(dataId)\n          } : fieldNameOrOptions, {\n            store: _this\n          });\n        }\n      };\n      Object.keys(storeObject).forEach(function (storeFieldName) {\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var fieldValue = storeObject[storeFieldName];\n        if (fieldValue === void 0) return;\n        var modify = typeof fields === \"function\" ? fields : fields[storeFieldName] || fields[fieldName];\n        if (modify) {\n          var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), {\n            fieldName: fieldName,\n            storeFieldName: storeFieldName,\n            storage: _this.getStorage(dataId, storeFieldName)\n          }));\n          if (newValue === INVALIDATE) {\n            _this.group.dirty(dataId, storeFieldName);\n          } else {\n            if (newValue === DELETE) newValue = void 0;\n            if (newValue !== fieldValue) {\n              changedFields_1[storeFieldName] = newValue;\n              needToMerge_1 = true;\n              fieldValue = newValue;\n              if (globalThis.__DEV__ !== false) {\n                var checkReference = function (ref) {\n                  if (_this.lookup(ref.__ref) === undefined) {\n                    globalThis.__DEV__ !== false && invariant.warn(3, ref);\n                    return true;\n                  }\n                };\n                if (isReference(newValue)) {\n                  checkReference(newValue);\n                } else if (Array.isArray(newValue)) {\n                  // Warn about writing \"mixed\" arrays of Reference and non-Reference objects\n                  var seenReference = false;\n                  var someNonReference = void 0;\n                  for (var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++) {\n                    var value = newValue_1[_i];\n                    if (isReference(value)) {\n                      seenReference = true;\n                      if (checkReference(value)) break;\n                    } else {\n                      // Do not warn on primitive values, since those could never be represented\n                      // by a reference. This is a valid (albeit uncommon) use case.\n                      if (typeof value === \"object\" && !!value) {\n                        var id = _this.policies.identify(value)[0];\n                        // check if object could even be referenced, otherwise we are not interested in it for this warning\n                        if (id) {\n                          someNonReference = value;\n                        }\n                      }\n                    }\n                    if (seenReference && someNonReference !== undefined) {\n                      globalThis.__DEV__ !== false && invariant.warn(4, someNonReference);\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (fieldValue !== void 0) {\n          allDeleted_1 = false;\n        }\n      });\n      if (needToMerge_1) {\n        this.merge(dataId, changedFields_1);\n        if (allDeleted_1) {\n          if (this instanceof Layer) {\n            this.data[dataId] = void 0;\n          } else {\n            delete this.data[dataId];\n          }\n          this.group.dirty(dataId, \"__exists\");\n        }\n        return true;\n      }\n    }\n    return false;\n  };\n  // If called with only one argument, removes the entire entity\n  // identified by dataId. If called with a fieldName as well, removes all\n  // fields of that entity whose names match fieldName according to the\n  // fieldNameFromStoreName helper function. If called with a fieldName\n  // and variables, removes all fields of that entity whose names match fieldName\n  // and whose arguments when cached exactly match the variables passed.\n  EntityStore.prototype.delete = function (dataId, fieldName, args) {\n    var _a;\n    var storeObject = this.lookup(dataId);\n    if (storeObject) {\n      var typename = this.getFieldValue(storeObject, \"__typename\");\n      var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({\n        typename: typename,\n        fieldName: fieldName,\n        args: args\n      }) : fieldName;\n      return this.modify(dataId, storeFieldName ? (_a = {}, _a[storeFieldName] = delModifier, _a) : delModifier);\n    }\n    return false;\n  };\n  EntityStore.prototype.evict = function (options, limit) {\n    var evicted = false;\n    if (options.id) {\n      if (hasOwn.call(this.data, options.id)) {\n        evicted = this.delete(options.id, options.fieldName, options.args);\n      }\n      if (this instanceof Layer && this !== limit) {\n        evicted = this.parent.evict(options, limit) || evicted;\n      }\n      // Always invalidate the field to trigger rereading of watched\n      // queries, even if no cache data was modified by the eviction,\n      // because queries may depend on computed fields with custom read\n      // functions, whose values are not stored in the EntityStore.\n      if (options.fieldName || evicted) {\n        this.group.dirty(options.id, options.fieldName || \"__exists\");\n      }\n    }\n    return evicted;\n  };\n  EntityStore.prototype.clear = function () {\n    this.replace(null);\n  };\n  EntityStore.prototype.extract = function () {\n    var _this = this;\n    var obj = this.toObject();\n    var extraRootIds = [];\n    this.getRootIdSet().forEach(function (id) {\n      if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {\n        extraRootIds.push(id);\n      }\n    });\n    if (extraRootIds.length) {\n      obj.__META = {\n        extraRootIds: extraRootIds.sort()\n      };\n    }\n    return obj;\n  };\n  EntityStore.prototype.replace = function (newData) {\n    var _this = this;\n    Object.keys(this.data).forEach(function (dataId) {\n      if (!(newData && hasOwn.call(newData, dataId))) {\n        _this.delete(dataId);\n      }\n    });\n    if (newData) {\n      var __META = newData.__META,\n        rest_1 = __rest(newData, [\"__META\"]);\n      Object.keys(rest_1).forEach(function (dataId) {\n        _this.merge(dataId, rest_1[dataId]);\n      });\n      if (__META) {\n        __META.extraRootIds.forEach(this.retain, this);\n      }\n    }\n  };\n  EntityStore.prototype.retain = function (rootId) {\n    return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;\n  };\n  EntityStore.prototype.release = function (rootId) {\n    if (this.rootIds[rootId] > 0) {\n      var count = --this.rootIds[rootId];\n      if (!count) delete this.rootIds[rootId];\n      return count;\n    }\n    return 0;\n  };\n  // Return a Set<string> of all the ID strings that have been retained by\n  // this layer/root *and* any layers/roots beneath it.\n  EntityStore.prototype.getRootIdSet = function (ids) {\n    if (ids === void 0) {\n      ids = new Set();\n    }\n    Object.keys(this.rootIds).forEach(ids.add, ids);\n    if (this instanceof Layer) {\n      this.parent.getRootIdSet(ids);\n    } else {\n      // Official singleton IDs like ROOT_QUERY and ROOT_MUTATION are\n      // always considered roots for garbage collection, regardless of\n      // their retainment counts in this.rootIds.\n      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n    }\n    return ids;\n  };\n  // The goal of garbage collection is to remove IDs from the Root layer of the\n  // store that are no longer reachable starting from any IDs that have been\n  // explicitly retained (see retain and release, above). Returns an array of\n  // dataId strings that were removed from the store.\n  EntityStore.prototype.gc = function () {\n    var _this = this;\n    var ids = this.getRootIdSet();\n    var snapshot = this.toObject();\n    ids.forEach(function (id) {\n      if (hasOwn.call(snapshot, id)) {\n        // Because we are iterating over an ECMAScript Set, the IDs we add here\n        // will be visited in later iterations of the forEach loop only if they\n        // were not previously contained by the Set.\n        Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);\n        // By removing IDs from the snapshot object here, we protect them from\n        // getting removed from the root store layer below.\n        delete snapshot[id];\n      }\n    });\n    var idsToRemove = Object.keys(snapshot);\n    if (idsToRemove.length) {\n      var root_1 = this;\n      while (root_1 instanceof Layer) root_1 = root_1.parent;\n      idsToRemove.forEach(function (id) {\n        return root_1.delete(id);\n      });\n    }\n    return idsToRemove;\n  };\n  EntityStore.prototype.findChildRefIds = function (dataId) {\n    if (!hasOwn.call(this.refs, dataId)) {\n      var found_1 = this.refs[dataId] = Object.create(null);\n      var root = this.data[dataId];\n      if (!root) return found_1;\n      var workSet_1 = new Set([root]);\n      // Within the store, only arrays and objects can contain child entity\n      // references, so we can prune the traversal using this predicate:\n      workSet_1.forEach(function (obj) {\n        if (isReference(obj)) {\n          found_1[obj.__ref] = true;\n          // In rare cases, a { __ref } Reference object may have other fields.\n          // This often indicates a mismerging of References with StoreObjects,\n          // but garbage collection should not be fooled by a stray __ref\n          // property in a StoreObject (ignoring all the other fields just\n          // because the StoreObject looks like a Reference). To avoid this\n          // premature termination of findChildRefIds recursion, we fall through\n          // to the code below, which will handle any other properties of obj.\n        }\n        if (isNonNullObject(obj)) {\n          Object.keys(obj).forEach(function (key) {\n            var child = obj[key];\n            // No need to add primitive values to the workSet, since they cannot\n            // contain reference objects.\n            if (isNonNullObject(child)) {\n              workSet_1.add(child);\n            }\n          });\n        }\n      });\n    }\n    return this.refs[dataId];\n  };\n  EntityStore.prototype.makeCacheKey = function () {\n    return this.group.keyMaker.lookupArray(arguments);\n  };\n  return EntityStore;\n}();\nexport { EntityStore };\n// A single CacheGroup represents a set of one or more EntityStore objects,\n// typically the Root store in a CacheGroup by itself, and all active Layer\n// stores in a group together. A single EntityStore object belongs to only\n// one CacheGroup, store.group. The CacheGroup is responsible for tracking\n// dependencies, so store.group is helpful for generating unique keys for\n// cached results that need to be invalidated when/if those dependencies\n// change. If we used the EntityStore objects themselves as cache keys (that\n// is, store rather than store.group), the cache would become unnecessarily\n// fragmented by all the different Layer objects. Instead, the CacheGroup\n// approach allows all optimistic Layer objects in the same linked list to\n// belong to one CacheGroup, with the non-optimistic Root object belonging\n// to another CacheGroup, allowing resultCaching dependencies to be tracked\n// separately for optimistic and non-optimistic entity data.\nvar CacheGroup = /** @class */function () {\n  function CacheGroup(caching, parent) {\n    if (parent === void 0) {\n      parent = null;\n    }\n    this.caching = caching;\n    this.parent = parent;\n    this.d = null;\n    this.resetCaching();\n  }\n  CacheGroup.prototype.resetCaching = function () {\n    this.d = this.caching ? dep() : null;\n    this.keyMaker = new Trie(canUseWeakMap);\n  };\n  CacheGroup.prototype.depend = function (dataId, storeFieldName) {\n    if (this.d) {\n      this.d(makeDepKey(dataId, storeFieldName));\n      var fieldName = fieldNameFromStoreName(storeFieldName);\n      if (fieldName !== storeFieldName) {\n        // Fields with arguments that contribute extra identifying\n        // information to the fieldName (thus forming the storeFieldName)\n        // depend not only on the full storeFieldName but also on the\n        // short fieldName, so the field can be invalidated using either\n        // level of specificity.\n        this.d(makeDepKey(dataId, fieldName));\n      }\n      if (this.parent) {\n        this.parent.depend(dataId, storeFieldName);\n      }\n    }\n  };\n  CacheGroup.prototype.dirty = function (dataId, storeFieldName) {\n    if (this.d) {\n      this.d.dirty(makeDepKey(dataId, storeFieldName),\n      // When storeFieldName === \"__exists\", that means the entity identified\n      // by dataId has either disappeared from the cache or was newly added,\n      // so the result caching system would do well to \"forget everything it\n      // knows\" about that object. To achieve that kind of invalidation, we\n      // not only dirty the associated result cache entry, but also remove it\n      // completely from the dependency graph. For the optimism implementation\n      // details, see https://github.com/benjamn/optimism/pull/195.\n      storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\");\n    }\n  };\n  return CacheGroup;\n}();\nfunction makeDepKey(dataId, storeFieldName) {\n  // Since field names cannot have '#' characters in them, this method\n  // of joining the field name and the ID should be unambiguous, and much\n  // cheaper than JSON.stringify([dataId, fieldName]).\n  return storeFieldName + \"#\" + dataId;\n}\nexport function maybeDependOnExistenceOfEntity(store, entityId) {\n  if (supportsResultCaching(store)) {\n    // We use this pseudo-field __exists elsewhere in the EntityStore code to\n    // represent changes in the existence of the entity object identified by\n    // entityId. This dependency gets reliably dirtied whenever an object with\n    // this ID is deleted (or newly created) within this group, so any result\n    // cache entries (for example, StoreReader#executeSelectionSet results) that\n    // depend on __exists for this entityId will get dirtied as well, leading to\n    // the eventual recomputation (instead of reuse) of those result objects the\n    // next time someone reads them from the cache.\n    store.group.depend(entityId, \"__exists\");\n  }\n}\n(function (EntityStore) {\n  // Refer to this class as EntityStore.Root outside this namespace.\n  var Root = /** @class */function (_super) {\n    __extends(Root, _super);\n    function Root(_a) {\n      var policies = _a.policies,\n        _b = _a.resultCaching,\n        resultCaching = _b === void 0 ? true : _b,\n        seed = _a.seed;\n      var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;\n      _this.stump = new Stump(_this);\n      _this.storageTrie = new Trie(canUseWeakMap);\n      if (seed) _this.replace(seed);\n      return _this;\n    }\n    Root.prototype.addLayer = function (layerId, replay) {\n      // Adding an optimistic Layer on top of the Root actually adds the Layer\n      // on top of the Stump, so the Stump always comes between the Root and\n      // any Layer objects that we've added.\n      return this.stump.addLayer(layerId, replay);\n    };\n    Root.prototype.removeLayer = function () {\n      // Never remove the root layer.\n      return this;\n    };\n    Root.prototype.getStorage = function () {\n      return this.storageTrie.lookupArray(arguments);\n    };\n    return Root;\n  }(EntityStore);\n  EntityStore.Root = Root;\n})(EntityStore || (EntityStore = {}));\n// Not exported, since all Layer instances are created by the addLayer method\n// of the EntityStore.Root class.\nvar Layer = /** @class */function (_super) {\n  __extends(Layer, _super);\n  function Layer(id, parent, replay, group) {\n    var _this = _super.call(this, parent.policies, group) || this;\n    _this.id = id;\n    _this.parent = parent;\n    _this.replay = replay;\n    _this.group = group;\n    replay(_this);\n    return _this;\n  }\n  Layer.prototype.addLayer = function (layerId, replay) {\n    return new Layer(layerId, this, replay, this.group);\n  };\n  Layer.prototype.removeLayer = function (layerId) {\n    var _this = this;\n    // Remove all instances of the given id, not just the first one.\n    var parent = this.parent.removeLayer(layerId);\n    if (layerId === this.id) {\n      if (this.group.caching) {\n        // Dirty every ID we're removing. Technically we might be able to avoid\n        // dirtying fields that have values in higher layers, but we don't have\n        // easy access to higher layers here, and we're about to recreate those\n        // layers anyway (see parent.addLayer below).\n        Object.keys(this.data).forEach(function (dataId) {\n          var ownStoreObject = _this.data[dataId];\n          var parentStoreObject = parent[\"lookup\"](dataId);\n          if (!parentStoreObject) {\n            // The StoreObject identified by dataId was defined in this layer\n            // but will be undefined in the parent layer, so we can delete the\n            // whole entity using this.delete(dataId). Since we're about to\n            // throw this layer away, the only goal of this deletion is to dirty\n            // the removed fields.\n            _this.delete(dataId);\n          } else if (!ownStoreObject) {\n            // This layer had an entry for dataId but it was undefined, which\n            // means the entity was deleted in this layer, and it's about to\n            // become undeleted when we remove this layer, so we need to dirty\n            // all fields that are about to be reexposed.\n            _this.group.dirty(dataId, \"__exists\");\n            Object.keys(parentStoreObject).forEach(function (storeFieldName) {\n              _this.group.dirty(dataId, storeFieldName);\n            });\n          } else if (ownStoreObject !== parentStoreObject) {\n            // If ownStoreObject is not exactly the same as parentStoreObject,\n            // dirty any fields whose values will change as a result of this\n            // removal.\n            Object.keys(ownStoreObject).forEach(function (storeFieldName) {\n              if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {\n                _this.group.dirty(dataId, storeFieldName);\n              }\n            });\n          }\n        });\n      }\n      return parent;\n    }\n    // No changes are necessary if the parent chain remains identical.\n    if (parent === this.parent) return this;\n    // Recreate this layer on top of the new parent.\n    return parent.addLayer(this.id, this.replay);\n  };\n  Layer.prototype.toObject = function () {\n    return __assign(__assign({}, this.parent.toObject()), this.data);\n  };\n  Layer.prototype.findChildRefIds = function (dataId) {\n    var fromParent = this.parent.findChildRefIds(dataId);\n    return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;\n  };\n  Layer.prototype.getStorage = function () {\n    var p = this.parent;\n    while (p.parent) p = p.parent;\n    return p.getStorage.apply(p,\n    // @ts-expect-error\n    arguments);\n  };\n  return Layer;\n}(EntityStore);\n// Represents a Layer permanently installed just above the Root, which allows\n// reading optimistically (and registering optimistic dependencies) even when\n// no optimistic layers are currently active. The stump.group CacheGroup object\n// is shared by any/all Layer objects added on top of the Stump.\nvar Stump = /** @class */function (_super) {\n  __extends(Stump, _super);\n  function Stump(root) {\n    return _super.call(this, \"EntityStore.Stump\", root, function () {}, new CacheGroup(root.group.caching, root.group)) || this;\n  }\n  Stump.prototype.removeLayer = function () {\n    // Never remove the Stump layer.\n    return this;\n  };\n  Stump.prototype.merge = function (older, newer) {\n    // We never want to write any data into the Stump, so we forward any merge\n    // calls to the Root instead. Another option here would be to throw an\n    // exception, but the toReference(object, true) function can sometimes\n    // trigger Stump writes (which used to be Root writes, before the Stump\n    // concept was introduced).\n    return this.parent.merge(older, newer);\n  };\n  return Stump;\n}(Layer);\nfunction storeObjectReconciler(existingObject, incomingObject, property) {\n  var existingValue = existingObject[property];\n  var incomingValue = incomingObject[property];\n  // Wherever there is a key collision, prefer the incoming value, unless\n  // it is deeply equal to the existing value. It's worth checking deep\n  // equality here (even though blindly returning incoming would be\n  // logically correct) because preserving the referential identity of\n  // existing data can prevent needless rereading and rerendering.\n  return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\nexport function supportsResultCaching(store) {\n  // When result caching is disabled, store.depend will be null.\n  return !!(store instanceof EntityStore && store.group.caching);\n}\n", "import { __assign } from \"tslib\";\nimport { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet, isNonNullObject as isObjectOrArray } from \"../../utilities/index.js\";\nimport { isArray } from \"./helpers.js\";\nfunction shallowCopy(value) {\n  if (isObjectOrArray(value)) {\n    return isArray(value) ? value.slice(0) : __assign({\n      __proto__: Object.getPrototypeOf(value)\n    }, value);\n  }\n  return value;\n}\n// When programmers talk about the \"canonical form\" of an object, they\n// usually have the following meaning in mind, which I've copied from\n// https://en.wiktionary.org/wiki/canonical_form:\n//\n// 1. A standard or normal presentation of a mathematical entity [or\n//    object]. A canonical form is an element of a set of representatives\n//    of equivalence classes of forms such that there is a function or\n//    procedure which projects every element of each equivalence class\n//    onto that one element, the canonical form of that equivalence\n//    class. The canonical form is expected to be simpler than the rest of\n//    the forms in some way.\n//\n// That's a long-winded way of saying any two objects that have the same\n// canonical form may be considered equivalent, even if they are !==,\n// which usually means the objects are structurally equivalent (deeply\n// equal), but don't necessarily use the same memory.\n//\n// Like a literary or musical canon, this ObjectCanon class represents a\n// collection of unique canonical items (JavaScript objects), with the\n// important property that canon.admit(a) === canon.admit(b) if a and b\n// are deeply equal to each other. In terms of the definition above, the\n// canon.admit method is the \"function or procedure which projects every\"\n// object \"onto that one element, the canonical form.\"\n//\n// In the worst case, the canonicalization process may involve looking at\n// every property in the provided object tree, so it takes the same order\n// of time as deep equality checking. Fortunately, already-canonicalized\n// objects are returned immediately from canon.admit, so the presence of\n// canonical subtrees tends to speed up canonicalization.\n//\n// Since consumers of canonical objects can check for deep equality in\n// constant time, canonicalizing cache results can massively improve the\n// performance of application code that skips re-rendering unchanged\n// results, such as \"pure\" UI components in a framework like React.\n//\n// Of course, since canonical objects may be shared widely between\n// unrelated consumers, it's important to think of them as immutable, even\n// though they are not actually frozen with Object.freeze in production,\n// due to the extra performance overhead that comes with frozen objects.\n//\n// Custom scalar objects whose internal class name is neither Array nor\n// Object can be included safely in the admitted tree, but they will not\n// be replaced with a canonical version (to put it another way, they are\n// assumed to be canonical already).\n//\n// If we ignore custom objects, no detection of cycles or repeated object\n// references is currently required by the StoreReader class, since\n// GraphQL result objects are JSON-serializable trees (and thus contain\n// neither cycles nor repeated subtrees), so we can avoid the complexity\n// of keeping track of objects we've already seen during the recursion of\n// the admit method.\n//\n// In the future, we may consider adding additional cases to the switch\n// statement to handle other common object types, such as \"[object Date]\"\n// objects, as needed.\nvar ObjectCanon = /** @class */function () {\n  function ObjectCanon() {\n    // Set of all canonical objects this ObjectCanon has admitted, allowing\n    // canon.admit to return previously-canonicalized objects immediately.\n    this.known = new (canUseWeakSet ? WeakSet : Set)();\n    // Efficient storage/lookup structure for canonical objects.\n    this.pool = new Trie(canUseWeakMap);\n    // Make the ObjectCanon assume this value has already been\n    // canonicalized.\n    this.passes = new WeakMap();\n    // Arrays that contain the same elements in a different order can share\n    // the same SortedKeysInfo object, to save memory.\n    this.keysByJSON = new Map();\n    // This has to come last because it depends on keysByJSON.\n    this.empty = this.admit({});\n  }\n  ObjectCanon.prototype.isKnown = function (value) {\n    return isObjectOrArray(value) && this.known.has(value);\n  };\n  ObjectCanon.prototype.pass = function (value) {\n    if (isObjectOrArray(value)) {\n      var copy = shallowCopy(value);\n      this.passes.set(copy, value);\n      return copy;\n    }\n    return value;\n  };\n  ObjectCanon.prototype.admit = function (value) {\n    var _this = this;\n    if (isObjectOrArray(value)) {\n      var original = this.passes.get(value);\n      if (original) return original;\n      var proto = Object.getPrototypeOf(value);\n      switch (proto) {\n        case Array.prototype:\n          {\n            if (this.known.has(value)) return value;\n            var array = value.map(this.admit, this);\n            // Arrays are looked up in the Trie using their recursively\n            // canonicalized elements, and the known version of the array is\n            // preserved as node.array.\n            var node = this.pool.lookupArray(array);\n            if (!node.array) {\n              this.known.add(node.array = array);\n              // Since canonical arrays may be shared widely between\n              // unrelated consumers, it's important to regard them as\n              // immutable, even if they are not frozen in production.\n              if (globalThis.__DEV__ !== false) {\n                Object.freeze(array);\n              }\n            }\n            return node.array;\n          }\n        case null:\n        case Object.prototype:\n          {\n            if (this.known.has(value)) return value;\n            var proto_1 = Object.getPrototypeOf(value);\n            var array_1 = [proto_1];\n            var keys = this.sortedKeys(value);\n            array_1.push(keys.json);\n            var firstValueIndex_1 = array_1.length;\n            keys.sorted.forEach(function (key) {\n              array_1.push(_this.admit(value[key]));\n            });\n            // Objects are looked up in the Trie by their prototype (which\n            // is *not* recursively canonicalized), followed by a JSON\n            // representation of their (sorted) keys, followed by the\n            // sequence of recursively canonicalized values corresponding to\n            // those keys. To keep the final results unambiguous with other\n            // sequences (such as arrays that just happen to contain [proto,\n            // keys.json, value1, value2, ...]), the known version of the\n            // object is stored as node.object.\n            var node = this.pool.lookupArray(array_1);\n            if (!node.object) {\n              var obj_1 = node.object = Object.create(proto_1);\n              this.known.add(obj_1);\n              keys.sorted.forEach(function (key, i) {\n                obj_1[key] = array_1[firstValueIndex_1 + i];\n              });\n              // Since canonical objects may be shared widely between\n              // unrelated consumers, it's important to regard them as\n              // immutable, even if they are not frozen in production.\n              if (globalThis.__DEV__ !== false) {\n                Object.freeze(obj_1);\n              }\n            }\n            return node.object;\n          }\n      }\n    }\n    return value;\n  };\n  // It's worthwhile to cache the sorting of arrays of strings, since the\n  // same initial unsorted arrays tend to be encountered many times.\n  // Fortunately, we can reuse the Trie machinery to look up the sorted\n  // arrays in linear time (which is faster than sorting large arrays).\n  ObjectCanon.prototype.sortedKeys = function (obj) {\n    var keys = Object.keys(obj);\n    var node = this.pool.lookupArray(keys);\n    if (!node.keys) {\n      keys.sort();\n      var json = JSON.stringify(keys);\n      if (!(node.keys = this.keysByJSON.get(json))) {\n        this.keysByJSON.set(json, node.keys = {\n          sorted: keys,\n          json: json\n        });\n      }\n    }\n    return node.keys;\n  };\n  return ObjectCanon;\n}();\nexport { ObjectCanon };\n", "import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { Kind } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { isField, resultKeyNameFromField, isReference, makeReference, shouldInclude, addTypenameToDocument, getDefaultValues, getMainDefinition, getQueryDefinition, getFragmentFromSelection, maybeDeepFreeze, mergeDeepArray, DeepMerger, isNonNullObject, canUseWeakMap, compact, canonicalStringify, cacheSizes } from \"../../utilities/index.js\";\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching } from \"./entityStore.js\";\nimport { isArray, extractFragmentContext, getTypenameFromStoreObject, shouldCanonizeResults } from \"./helpers.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { ObjectCanon } from \"./object-canon.js\";\nfunction execSelectionSetKeyArgs(options) {\n  return [options.selectionSet, options.objectOrReference, options.context,\n  // We split out this property so we can pass different values\n  // independently without modifying options.context itself.\n  options.context.canonizeResults];\n}\nvar StoreReader = /** @class */function () {\n  function StoreReader(config) {\n    var _this = this;\n    this.knownResults = new (canUseWeakMap ? WeakMap : Map)();\n    this.config = compact(config, {\n      addTypename: config.addTypename !== false,\n      canonizeResults: shouldCanonizeResults(config)\n    });\n    this.canon = config.canon || new ObjectCanon();\n    // memoized functions in this class will be \"garbage-collected\"\n    // by recreating the whole `StoreReader` in\n    // `InMemoryCache.resetResultsCache`\n    // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n    this.executeSelectionSet = wrap(function (options) {\n      var _a;\n      var canonizeResults = options.context.canonizeResults;\n      var peekArgs = execSelectionSetKeyArgs(options);\n      // Negate this boolean option so we can find out if we've already read\n      // this result using the other boolean value.\n      peekArgs[3] = !canonizeResults;\n      var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\n      if (other) {\n        if (canonizeResults) {\n          return __assign(__assign({}, other), {\n            // If we previously read this result without canonizing it, we can\n            // reuse that result simply by canonizing it now.\n            result: _this.canon.admit(other.result)\n          });\n        }\n        // If we previously read this result with canonization enabled, we can\n        // return that canonized result as-is.\n        return other;\n      }\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n      // Finally, if we didn't find any useful previous results, run the real\n      // execSelectionSetImpl method with the given options.\n      return _this.execSelectionSetImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize || cacheSizes[\"inMemoryCache.executeSelectionSet\"] || 50000 /* defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"] */,\n      keyArgs: execSelectionSetKeyArgs,\n      // Note that the parameters of makeCacheKey are determined by the\n      // array returned by keyArgs.\n      makeCacheKey: function (selectionSet, parent, context, canonizeResults) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);\n        }\n      }\n    });\n    this.executeSubSelectedArray = wrap(function (options) {\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n      return _this.execSubSelectedArrayImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize || cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] || 10000 /* defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"] */,\n      makeCacheKey: function (_a) {\n        var field = _a.field,\n          array = _a.array,\n          context = _a.context;\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(field, array, context.varString);\n        }\n      }\n    });\n  }\n  StoreReader.prototype.resetCanon = function () {\n    this.canon = new ObjectCanon();\n  };\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   */\n  StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n    var store = _a.store,\n      query = _a.query,\n      _b = _a.rootId,\n      rootId = _b === void 0 ? \"ROOT_QUERY\" : _b,\n      variables = _a.variables,\n      _c = _a.returnPartialData,\n      returnPartialData = _c === void 0 ? true : _c,\n      _d = _a.canonizeResults,\n      canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;\n    var policies = this.config.cache.policies;\n    variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);\n    var rootRef = makeReference(rootId);\n    var execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: __assign({\n        store: store,\n        query: query,\n        policies: policies,\n        variables: variables,\n        varString: canonicalStringify(variables),\n        canonizeResults: canonizeResults\n      }, extractFragmentContext(query, this.config.fragments))\n    });\n    var missing;\n    if (execResult.missing) {\n      // For backwards compatibility we still report an array of\n      // MissingFieldError objects, even though there will only ever be at most\n      // one of them, now that all missing field error messages are grouped\n      // together in the execResult.missing tree.\n      missing = [new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)];\n      if (!returnPartialData) {\n        throw missing[0];\n      }\n    }\n    return {\n      result: execResult.result,\n      complete: !missing,\n      missing: missing\n    };\n  };\n  StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\n    if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {\n      var latest = this.executeSelectionSet.peek(selectionSet, parent, context,\n      // If result is canonical, then it could only have been previously\n      // cached by the canonizing version of executeSelectionSet, so we can\n      // avoid checking both possibilities here.\n      this.canon.isKnown(result));\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  };\n  // Uncached version of executeSelectionSet.\n  StoreReader.prototype.execSelectionSetImpl = function (_a) {\n    var _this = this;\n    var selectionSet = _a.selectionSet,\n      objectOrReference = _a.objectOrReference,\n      enclosingRef = _a.enclosingRef,\n      context = _a.context;\n    if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: this.canon.empty,\n        missing: \"Dangling reference to missing \".concat(objectOrReference.__ref, \" object\")\n      };\n    }\n    var variables = context.variables,\n      policies = context.policies,\n      store = context.store;\n    var typename = store.getFieldValue(objectOrReference, \"__typename\");\n    var objectsToMerge = [];\n    var missing;\n    var missingMerger = new DeepMerger();\n    if (this.config.addTypename && typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one, and this.config.addTypename is true. Note\n      // that this field can be overridden by other merged objects.\n      objectsToMerge.push({\n        __typename: typename\n      });\n    }\n    function handleMissing(result, resultName) {\n      var _a;\n      if (result.missing) {\n        missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = result.missing, _a));\n      }\n      return result.result;\n    }\n    var workSet = new Set(selectionSet.selections);\n    workSet.forEach(function (selection) {\n      var _a, _b;\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n      if (isField(selection)) {\n        var fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference\n        }, context);\n        var resultName = resultKeyNameFromField(selection);\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = \"Can't find field '\".concat(selection.name.value, \"' on \").concat(isReference(objectOrReference) ? objectOrReference.__ref + \" object\" : \"object \" + JSON.stringify(objectOrReference, null, 2)), _a));\n          }\n        } else if (isArray(fieldValue)) {\n          if (fieldValue.length > 0) {\n            fieldValue = handleMissing(_this.executeSubSelectedArray({\n              field: selection,\n              array: fieldValue,\n              enclosingRef: enclosingRef,\n              context: context\n            }), resultName);\n          }\n        } else if (!selection.selectionSet) {\n          // If the field does not have a selection set, then we handle it\n          // as a scalar value. To keep this.canon from canonicalizing\n          // this value, we use this.canon.pass to wrap fieldValue in a\n          // Pass object that this.canon.admit will later unwrap as-is.\n          if (context.canonizeResults) {\n            fieldValue = _this.canon.pass(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(_this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue,\n            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n            context: context\n          }), resultName);\n        }\n        if (fieldValue !== void 0) {\n          objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n          throw newInvariantError(10, selection.name.value);\n        }\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n    var result = mergeDeepArray(objectsToMerge);\n    var finalResult = {\n      result: result,\n      missing: missing\n    };\n    var frozen = context.canonizeResults ? this.canon.admit(finalResult)\n    // Since this.canon is normally responsible for freezing results (only in\n    // development), freeze them manually if canonization is disabled.\n    : maybeDeepFreeze(finalResult);\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n    return frozen;\n  };\n  // Uncached version of executeSubSelectedArray.\n  StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\n    var _this = this;\n    var field = _a.field,\n      array = _a.array,\n      enclosingRef = _a.enclosingRef,\n      context = _a.context;\n    var missing;\n    var missingMerger = new DeepMerger();\n    function handleMissing(childResult, i) {\n      var _a;\n      if (childResult.missing) {\n        missing = missingMerger.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));\n      }\n      return childResult.result;\n    }\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n    array = array.map(function (item, i) {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n      // This is a nested array, recurse\n      if (isArray(item)) {\n        return handleMissing(_this.executeSubSelectedArray({\n          field: field,\n          array: item,\n          enclosingRef: enclosingRef,\n          context: context\n        }), i);\n      }\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(_this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          enclosingRef: isReference(item) ? item : enclosingRef,\n          context: context\n        }), i);\n      }\n      if (globalThis.__DEV__ !== false) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n      return item;\n    });\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing: missing\n    };\n  };\n  return StoreReader;\n}();\nexport { StoreReader };\nfunction firstMissing(tree) {\n  try {\n    JSON.stringify(tree, function (_, value) {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result;\n  }\n}\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n  if (!field.selectionSet) {\n    var workSet_1 = new Set([fieldValue]);\n    workSet_1.forEach(function (value) {\n      if (isNonNullObject(value)) {\n        invariant(!isReference(value), 11, getTypenameFromStoreObject(store, value), field.name.value);\n        Object.values(value).forEach(workSet_1.add, workSet_1);\n      }\n    });\n  }\n}\n", "import { dep, Slot } from \"optimism\";\n// Contextual Slot that acquires its value when custom read functions are\n// called in Policies#readField.\nexport var cacheSlot = new Slot();\nvar cacheInfoMap = new WeakMap();\nfunction getCacheInfo(cache) {\n  var info = cacheInfoMap.get(cache);\n  if (!info) {\n    cacheInfoMap.set(cache, info = {\n      vars: new Set(),\n      dep: dep()\n    });\n  }\n  return info;\n}\nexport function forgetCache(cache) {\n  getCacheInfo(cache).vars.forEach(function (rv) {\n    return rv.forgetCache(cache);\n  });\n}\n// Calling forgetCache(cache) serves to silence broadcasts and allows the\n// cache to be garbage collected. However, the varsByCache WeakMap\n// preserves the set of reactive variables that were previously associated\n// with this cache, which makes it possible to \"recall\" the cache at a\n// later time, by reattaching it to those variables. If the cache has been\n// garbage collected in the meantime, because it is no longer reachable,\n// you won't be able to call recallCache(cache), and the cache will\n// automatically disappear from the varsByCache WeakMap.\nexport function recallCache(cache) {\n  getCacheInfo(cache).vars.forEach(function (rv) {\n    return rv.attachCache(cache);\n  });\n}\nexport function makeVar(value) {\n  var caches = new Set();\n  var listeners = new Set();\n  var rv = function (newValue) {\n    if (arguments.length > 0) {\n      if (value !== newValue) {\n        value = newValue;\n        caches.forEach(function (cache) {\n          // Invalidate any fields with custom read functions that\n          // consumed this variable, so query results involving those\n          // fields will be recomputed the next time we read them.\n          getCacheInfo(cache).dep.dirty(rv);\n          // Broadcast changes to any caches that have previously read\n          // from this variable.\n          broadcast(cache);\n        });\n        // Finally, notify any listeners added via rv.onNextChange.\n        var oldListeners = Array.from(listeners);\n        listeners.clear();\n        oldListeners.forEach(function (listener) {\n          return listener(value);\n        });\n      }\n    } else {\n      // When reading from the variable, obtain the current cache from\n      // context via cacheSlot. This isn't entirely foolproof, but it's\n      // the same system that powers varDep.\n      var cache = cacheSlot.getValue();\n      if (cache) {\n        attach(cache);\n        getCacheInfo(cache).dep(rv);\n      }\n    }\n    return value;\n  };\n  rv.onNextChange = function (listener) {\n    listeners.add(listener);\n    return function () {\n      listeners.delete(listener);\n    };\n  };\n  var attach = rv.attachCache = function (cache) {\n    caches.add(cache);\n    getCacheInfo(cache).vars.add(rv);\n    return rv;\n  };\n  rv.forgetCache = function (cache) {\n    return caches.delete(cache);\n  };\n  return rv;\n}\nfunction broadcast(cache) {\n  if (cache.broadcastWatches) {\n    cache.broadcastWatches();\n  }\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport { argumentsObjectFromField, DeepMerger, isNonEmptyArray, isNonNullObject } from \"../../utilities/index.js\";\nimport { hasOwn, isArray } from \"./helpers.js\";\n// Mapping from JSON-encoded KeySpecifier strings to associated information.\nvar specifierInfoCache = Object.create(null);\nfunction lookupSpecifierInfo(spec) {\n  // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n  // just arrays of strings or nested KeySpecifier arrays, and the order of the\n  // array elements is important (and suitably preserved by JSON.stringify).\n  var cacheKey = JSON.stringify(spec);\n  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = Object.create(null));\n}\nexport function keyFieldsFnFromSpecifier(specifier) {\n  var info = lookupSpecifierInfo(specifier);\n  return info.keyFieldsFn || (info.keyFieldsFn = function (object, context) {\n    var extract = function (from, key) {\n      return context.readField(key, from);\n    };\n    var keyObject = context.keyObject = collectSpecifierPaths(specifier, function (schemaKeyPath) {\n      var extracted = extractKeyPath(context.storeObject, schemaKeyPath,\n      // Using context.readField to extract paths from context.storeObject\n      // allows the extraction to see through Reference objects and respect\n      // custom read functions.\n      extract);\n      if (extracted === void 0 && object !== context.storeObject && hasOwn.call(object, schemaKeyPath[0])) {\n        // If context.storeObject fails to provide a value for the requested\n        // path, fall back to the raw result object, if it has a top-level key\n        // matching the first key in the path (schemaKeyPath[0]). This allows\n        // key fields included in the written data to be saved in the cache\n        // even if they are not selected explicitly in context.selectionSet.\n        // Not being mentioned by context.selectionSet is convenient here,\n        // since it means these extra fields cannot be affected by field\n        // aliasing, which is why we can use extractKey instead of\n        // context.readField for this extraction.\n        extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n      }\n      invariant(extracted !== void 0, 5, schemaKeyPath.join(\".\"), object);\n      return extracted;\n    });\n    return \"\".concat(context.typename, \":\").concat(JSON.stringify(keyObject));\n  });\n}\n// The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\nexport function keyArgsFnFromSpecifier(specifier) {\n  var info = lookupSpecifierInfo(specifier);\n  return info.keyArgsFn || (info.keyArgsFn = function (args, _a) {\n    var field = _a.field,\n      variables = _a.variables,\n      fieldName = _a.fieldName;\n    var collected = collectSpecifierPaths(specifier, function (keyPath) {\n      var firstKey = keyPath[0];\n      var firstChar = firstKey.charAt(0);\n      if (firstChar === \"@\") {\n        if (field && isNonEmptyArray(field.directives)) {\n          var directiveName_1 = firstKey.slice(1);\n          // If the directive appears multiple times, only the first\n          // occurrence's arguments will be used. TODO Allow repetition?\n          // TODO Cache this work somehow, a la aliasMap?\n          var d = field.directives.find(function (d) {\n            return d.name.value === directiveName_1;\n          });\n          // Fortunately argumentsObjectFromField works for DirectiveNode!\n          var directiveArgs = d && argumentsObjectFromField(d, variables);\n          // For directives without arguments (d defined, but directiveArgs ===\n          // null), the presence or absence of the directive still counts as\n          // part of the field key, so we return null in those cases. If no\n          // directive with this name was found for this field (d undefined and\n          // thus directiveArgs undefined), we return undefined, which causes\n          // this value to be omitted from the key object returned by\n          // collectSpecifierPaths.\n          return directiveArgs && extractKeyPath(directiveArgs,\n          // If keyPath.length === 1, this code calls extractKeyPath with an\n          // empty path, which works because it uses directiveArgs as the\n          // extracted value.\n          keyPath.slice(1));\n        }\n        // If the key started with @ but there was no corresponding directive,\n        // we want to omit this value from the key object, not fall through to\n        // treating @whatever as a normal argument name.\n        return;\n      }\n      if (firstChar === \"$\") {\n        var variableName = firstKey.slice(1);\n        if (variables && hasOwn.call(variables, variableName)) {\n          var varKeyPath = keyPath.slice(0);\n          varKeyPath[0] = variableName;\n          return extractKeyPath(variables, varKeyPath);\n        }\n        // If the key started with $ but there was no corresponding variable, we\n        // want to omit this value from the key object, not fall through to\n        // treating $whatever as a normal argument name.\n        return;\n      }\n      if (args) {\n        return extractKeyPath(args, keyPath);\n      }\n    });\n    var suffix = JSON.stringify(collected);\n    // If no arguments were passed to this field, and it didn't have any other\n    // field key contributions from directives or variables, hide the empty\n    // :{} suffix from the field key. However, a field passed no arguments can\n    // still end up with a non-empty :{...} suffix if its key configuration\n    // refers to directives or variables.\n    if (args || suffix !== \"{}\") {\n      fieldName += \":\" + suffix;\n    }\n    return fieldName;\n  });\n}\nexport function collectSpecifierPaths(specifier, extractor) {\n  // For each path specified by specifier, invoke the extractor, and repeatedly\n  // merge the results together, with appropriate ancestor context.\n  var merger = new DeepMerger();\n  return getSpecifierPaths(specifier).reduce(function (collected, path) {\n    var _a;\n    var toMerge = extractor(path);\n    if (toMerge !== void 0) {\n      // This path is not expected to contain array indexes, so the toMerge\n      // reconstruction will not contain arrays. TODO Fix this?\n      for (var i = path.length - 1; i >= 0; --i) {\n        toMerge = (_a = {}, _a[path[i]] = toMerge, _a);\n      }\n      collected = merger.merge(collected, toMerge);\n    }\n    return collected;\n  }, Object.create(null));\n}\nexport function getSpecifierPaths(spec) {\n  var info = lookupSpecifierInfo(spec);\n  if (!info.paths) {\n    var paths_1 = info.paths = [];\n    var currentPath_1 = [];\n    spec.forEach(function (s, i) {\n      if (isArray(s)) {\n        getSpecifierPaths(s).forEach(function (p) {\n          return paths_1.push(currentPath_1.concat(p));\n        });\n        currentPath_1.length = 0;\n      } else {\n        currentPath_1.push(s);\n        if (!isArray(spec[i + 1])) {\n          paths_1.push(currentPath_1.slice(0));\n          currentPath_1.length = 0;\n        }\n      }\n    });\n  }\n  return info.paths;\n}\nfunction extractKey(object, key) {\n  return object[key];\n}\nexport function extractKeyPath(object, path, extract) {\n  // For each key in path, extract the corresponding child property from obj,\n  // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n  // possible). The final result of path.reduce is normalized so unexpected leaf\n  // objects have their keys safely sorted. That final result is difficult to\n  // type as anything other than any. You're welcome to try to improve the\n  // return type, but keep in mind extractKeyPath is not a public function\n  // (exported only for testing), so the effort may not be worthwhile unless the\n  // limited set of actual callers (see above) pass arguments that TypeScript\n  // can statically type. If we know only that path is some array of strings\n  // (and not, say, a specific tuple of statically known strings), any (or\n  // possibly unknown) is the honest answer.\n  extract = extract || extractKey;\n  return normalize(path.reduce(function reducer(obj, key) {\n    return isArray(obj) ? obj.map(function (child) {\n      return reducer(child, key);\n    }) : obj && extract(obj, key);\n  }, object));\n}\nfunction normalize(value) {\n  // Usually the extracted value will be a scalar value, since most primary\n  // key fields are scalar, but just in case we get an object or an array, we\n  // need to do some normalization of the order of (nested) keys.\n  if (isNonNullObject(value)) {\n    if (isArray(value)) {\n      return value.map(normalize);\n    }\n    return collectSpecifierPaths(Object.keys(value).sort(), function (path) {\n      return extractKeyPath(value, path);\n    });\n  }\n  return value;\n}\n", "import { __assign, __rest } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, isNonNullObject, stringifyForDisplay } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp, defaultDataIdFromObject, isArray } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier } from \"./key-extractor.js\";\nimport { disableWarningsSlot } from \"../../masking/index.js\";\nfunction argsFromFieldSpecifier(spec) {\n  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\nvar nullKeyFieldsFn = function () {\n  return void 0;\n};\nvar simpleKeyArgsFn = function (_args, context) {\n  return context.fieldName;\n};\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nvar mergeTrueFn = function (existing, incoming, _a) {\n  var mergeObjects = _a.mergeObjects;\n  return mergeObjects(existing, incoming);\n};\nvar mergeFalseFn = function (_, incoming) {\n  return incoming;\n};\nvar Policies = /** @class */function () {\n  function Policies(config) {\n    this.config = config;\n    this.typePolicies = Object.create(null);\n    this.toBeAdded = Object.create(null);\n    // Map from subtype names to sets of supertype names. Note that this\n    // representation inverts the structure of possibleTypes (whose keys are\n    // supertypes and whose values are arrays of subtypes) because it tends\n    // to be much more efficient to search upwards than downwards.\n    this.supertypeMap = new Map();\n    // Any fuzzy subtypes specified by possibleTypes will be converted to\n    // RegExp objects and recorded here. Every key of this map can also be\n    // found in supertypeMap. In many cases this Map will be empty, which\n    // means no fuzzy subtype checking will happen in fragmentMatches.\n    this.fuzzySubtypes = new Map();\n    this.rootIdsByTypename = Object.create(null);\n    this.rootTypenamesById = Object.create(null);\n    this.usingPossibleTypes = false;\n    this.config = __assign({\n      dataIdFromObject: defaultDataIdFromObject\n    }, config);\n    this.cache = this.config.cache;\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n  Policies.prototype.identify = function (object, partialContext) {\n    var _a;\n    var policies = this;\n    var typename = partialContext && (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename)) || object.__typename;\n    // It should be possible to write root Query fields with writeFragment,\n    // using { __typename: \"Query\", ... } as the data, but it does not make\n    // sense to allow the same identification behavior for the Mutation and\n    // Subscription types, since application code should never be writing\n    // directly to (or reading directly from) those root objects.\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n    // Default context.storeObject to object if not otherwise provided.\n    var storeObject = partialContext && partialContext.storeObject || object;\n    var context = __assign(__assign({}, partialContext), {\n      typename: typename,\n      storeObject: storeObject,\n      readField: partialContext && partialContext.readField || function () {\n        var options = normalizeReadFieldOptions(arguments, storeObject);\n        return policies.readField(options, {\n          store: policies.cache[\"data\"],\n          variables: options.variables\n        });\n      }\n    });\n    var id;\n    var policy = typename && this.getTypePolicy(typename);\n    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n    disableWarningsSlot.withValue(true, function () {\n      while (keyFn) {\n        var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);\n        if (isArray(specifierOrId)) {\n          keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n        } else {\n          id = specifierOrId;\n          break;\n        }\n      }\n    });\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  };\n  Policies.prototype.addTypePolicies = function (typePolicies) {\n    var _this = this;\n    Object.keys(typePolicies).forEach(function (typename) {\n      var _a = typePolicies[typename],\n        queryType = _a.queryType,\n        mutationType = _a.mutationType,\n        subscriptionType = _a.subscriptionType,\n        incoming = __rest(_a, [\"queryType\", \"mutationType\", \"subscriptionType\"]);\n      // Though {query,mutation,subscription}Type configurations are rare,\n      // it's important to call setRootTypename as early as possible,\n      // since these configurations should apply consistently for the\n      // entire lifetime of the cache. Also, since only one __typename can\n      // qualify as one of these root types, these three properties cannot\n      // be inherited, unlike the rest of the incoming properties. That\n      // restriction is convenient, because the purpose of this.toBeAdded\n      // is to delay the processing of type/field policies until the first\n      // time they're used, allowing policies to be added in any order as\n      // long as all relevant policies (including policies for supertypes)\n      // have been added by the time a given policy is used for the first\n      // time. In other words, since inheritance doesn't matter for these\n      // properties, there's also no need to delay their processing using\n      // the this.toBeAdded queue.\n      if (queryType) _this.setRootTypename(\"Query\", typename);\n      if (mutationType) _this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) _this.setRootTypename(\"Subscription\", typename);\n      if (hasOwn.call(_this.toBeAdded, typename)) {\n        _this.toBeAdded[typename].push(incoming);\n      } else {\n        _this.toBeAdded[typename] = [incoming];\n      }\n    });\n  };\n  Policies.prototype.updateTypePolicy = function (typename, incoming) {\n    var _this = this;\n    var existing = this.getTypePolicy(typename);\n    var keyFields = incoming.keyFields,\n      fields = incoming.fields;\n    function setMerge(existing, merge) {\n      existing.merge = typeof merge === \"function\" ? merge\n      // Pass merge:true as a shorthand for a merge implementation\n      // that returns options.mergeObjects(existing, incoming).\n      : merge === true ? mergeTrueFn\n      // Pass merge:false to make incoming always replace existing\n      // without any warnings about data clobbering.\n      : merge === false ? mergeFalseFn : existing.merge;\n    }\n    // Type policies can define merge functions, as an alternative to\n    // using field policies to merge child objects.\n    setMerge(existing, incoming.merge);\n    existing.keyFn =\n    // Pass false to disable normalization for this typename.\n    keyFields === false ? nullKeyFieldsFn\n    // Pass an array of strings to use those fields to compute a\n    // composite ID for objects of this typename.\n    : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields)\n    // Pass a function to take full control over identification.\n    : typeof keyFields === \"function\" ? keyFields\n    // Leave existing.keyFn unchanged if above cases fail.\n    : existing.keyFn;\n    if (fields) {\n      Object.keys(fields).forEach(function (fieldName) {\n        var existing = _this.getFieldPolicy(typename, fieldName, true);\n        var incoming = fields[fieldName];\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          var keyArgs = incoming.keyArgs,\n            read = incoming.read,\n            merge = incoming.merge;\n          existing.keyFn =\n          // Pass false to disable argument-based differentiation of\n          // field identities.\n          keyArgs === false ? simpleKeyArgsFn\n          // Pass an array of strings to use named arguments to\n          // compute a composite identity for the field.\n          : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs)\n          // Pass a function to take full control over field identity.\n          : typeof keyArgs === \"function\" ? keyArgs\n          // Leave existing.keyFn unchanged if above cases fail.\n          : existing.keyFn;\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n          setMerge(existing, merge);\n        }\n        if (existing.read && existing.merge) {\n          // If we have both a read and a merge function, assume\n          // keyArgs:false, because read and merge together can take\n          // responsibility for interpreting arguments in and out. This\n          // default assumption can always be overridden by specifying\n          // keyArgs explicitly in the FieldPolicy.\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  };\n  Policies.prototype.setRootTypename = function (which, typename) {\n    if (typename === void 0) {\n      typename = which;\n    }\n    var rootId = \"ROOT_\" + which.toUpperCase();\n    var old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      invariant(!old || old === which, 6, which);\n      // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n      if (old) delete this.rootIdsByTypename[old];\n      // Now make this the only __typename that maps to this rootId.\n      this.rootIdsByTypename[typename] = rootId;\n      // Finally, update the __typename associated with this rootId.\n      this.rootTypenamesById[rootId] = typename;\n    }\n  };\n  Policies.prototype.addPossibleTypes = function (possibleTypes) {\n    var _this = this;\n    this.usingPossibleTypes = true;\n    Object.keys(possibleTypes).forEach(function (supertype) {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      _this.getSupertypeSet(supertype, true);\n      possibleTypes[supertype].forEach(function (subtype) {\n        _this.getSupertypeSet(subtype, true).add(supertype);\n        var match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  };\n  Policies.prototype.getTypePolicy = function (typename) {\n    var _this = this;\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      var policy_1 = this.typePolicies[typename] = Object.create(null);\n      policy_1.fields = Object.create(null);\n      // When the TypePolicy for typename is first accessed, instead of\n      // starting with an empty policy object, inherit any properties or\n      // fields from the type policies of the supertypes of typename.\n      //\n      // Any properties or fields defined explicitly within the TypePolicy\n      // for typename will take precedence, and if there are multiple\n      // supertypes, the properties of policies whose types were added\n      // later via addPossibleTypes will take precedence over those of\n      // earlier supertypes. TODO Perhaps we should warn about these\n      // conflicts in development, and recommend defining the property\n      // explicitly in the subtype policy?\n      //\n      // Field policy inheritance is atomic/shallow: you can't inherit a\n      // field policy and then override just its read function, since read\n      // and merge functions often need to cooperate, so changing only one\n      // of them would be a recipe for inconsistency.\n      //\n      // Once the TypePolicy for typename has been accessed, its properties can\n      // still be updated directly using addTypePolicies, but future changes to\n      // inherited supertype policies will not be reflected in this subtype\n      // policy, because this code runs at most once per typename.\n      var supertypes_1 = this.supertypeMap.get(typename);\n      if (!supertypes_1 && this.fuzzySubtypes.size) {\n        // To make the inheritance logic work for unknown typename strings that\n        // may have fuzzy supertypes, we give this typename an empty supertype\n        // set and then populate it with any fuzzy supertypes that match.\n        supertypes_1 = this.getSupertypeSet(typename, true);\n        // This only works for typenames that are directly matched by a fuzzy\n        // supertype. What if there is an intermediate chain of supertypes?\n        // While possible, that situation can only be solved effectively by\n        // specifying the intermediate relationships via possibleTypes, manually\n        // and in a non-fuzzy way.\n        this.fuzzySubtypes.forEach(function (regExp, fuzzy) {\n          if (regExp.test(typename)) {\n            // The fuzzy parameter is just the original string version of regExp\n            // (not a valid __typename string), but we can look up the\n            // associated supertype(s) in this.supertypeMap.\n            var fuzzySupertypes = _this.supertypeMap.get(fuzzy);\n            if (fuzzySupertypes) {\n              fuzzySupertypes.forEach(function (supertype) {\n                return supertypes_1.add(supertype);\n              });\n            }\n          }\n        });\n      }\n      if (supertypes_1 && supertypes_1.size) {\n        supertypes_1.forEach(function (supertype) {\n          var _a = _this.getTypePolicy(supertype),\n            fields = _a.fields,\n            rest = __rest(_a, [\"fields\"]);\n          Object.assign(policy_1, rest);\n          Object.assign(policy_1.fields, fields);\n        });\n      }\n    }\n    var inbox = this.toBeAdded[typename];\n    if (inbox && inbox.length) {\n      // Merge the pending policies into this.typePolicies, in the order they\n      // were originally passed to addTypePolicy.\n      inbox.splice(0).forEach(function (policy) {\n        _this.updateTypePolicy(typename, policy);\n      });\n    }\n    return this.typePolicies[typename];\n  };\n  Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n    if (typename) {\n      var fieldPolicies = this.getTypePolicy(typename).fields;\n      return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));\n    }\n  };\n  Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\n    var supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, supertypeSet = new Set());\n    }\n    return supertypeSet;\n  };\n  Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\n    var _this = this;\n    if (!fragment.typeCondition) return true;\n    // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n    if (!typename) return false;\n    var supertype = fragment.typeCondition.name.value;\n    // Common case: fragment type condition and __typename are the same.\n    if (typename === supertype) return true;\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n      var workQueue_1 = [typenameSupertypeSet];\n      var maybeEnqueue_1 = function (subtype) {\n        var supertypeSet = _this.getSupertypeSet(subtype, false);\n        if (supertypeSet && supertypeSet.size && workQueue_1.indexOf(supertypeSet) < 0) {\n          workQueue_1.push(supertypeSet);\n        }\n      };\n      // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n      var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      var checkingFuzzySubtypes = false;\n      // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n      for (var i = 0; i < workQueue_1.length; ++i) {\n        var supertypeSet = workQueue_1[i];\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              globalThis.__DEV__ !== false && invariant.warn(7, typename, supertype);\n            }\n            // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n        supertypeSet.forEach(maybeEnqueue_1);\n        if (needToCheckFuzzySubtypes &&\n        // Start checking fuzzy subtypes only after exhausting all\n        // non-fuzzy subtypes (after the final iteration of the loop).\n        i === workQueue_1.length - 1 &&\n        // We could wait to compare fragment.selectionSet to result\n        // after we verify the supertype, but this check is often less\n        // expensive than that search, and we will have to do the\n        // comparison anyway whenever we find a potential match.\n        selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n          // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n          this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\n            var match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue_1(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n    return false;\n  };\n  Policies.prototype.hasKeyArgs = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.keyFn);\n  };\n  Policies.prototype.getStoreFieldName = function (fieldSpec) {\n    var typename = fieldSpec.typename,\n      fieldName = fieldSpec.fieldName;\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    var storeFieldName;\n    var keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      var context = {\n        typename: typename,\n        fieldName: fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables\n      };\n      var args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        var specifierOrString = keyFn(args, context);\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n    // Returning false from a keyArgs function is like configuring\n    // keyArgs: false, but more dynamic.\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n    // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n  };\n  Policies.prototype.readField = function (options, context) {\n    var objectOrReference = options.from;\n    if (!objectOrReference) return;\n    var nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n    if (options.typename === void 0) {\n      var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n    var storeFieldName = this.getStoreFieldName(options);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n    var policy = this.getFieldPolicy(options.typename, fieldName, false);\n    var read = policy && policy.read;\n    if (read) {\n      var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));\n      // Call read(existing, readOptions) with cacheSlot holding this.cache.\n      return cacheSlot.withValue(this.cache, read, [existing, readOptions]);\n    }\n    return existing;\n  };\n  Policies.prototype.getReadFunction = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return policy && policy.read;\n  };\n  Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {\n    var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n    var merge = policy && policy.merge;\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n    return merge;\n  };\n  Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {\n    var field = _a.field,\n      typename = _a.typename,\n      merge = _a.merge;\n    if (merge === mergeTrueFn) {\n      // Instead of going to the trouble of creating a full\n      // FieldFunctionOptions object and calling mergeTrueFn, we can\n      // simply call mergeObjects, as mergeTrueFn would.\n      return makeMergeObjectsFunction(context.store)(existing, incoming);\n    }\n    if (merge === mergeFalseFn) {\n      // Likewise for mergeFalseFn, whose implementation is even simpler.\n      return incoming;\n    }\n    // If cache.writeQuery or cache.writeFragment was called with\n    // options.overwrite set to true, we still call merge functions, but\n    // the existing data is always undefined, so the merge function will\n    // not attempt to combine the incoming data with the existing data.\n    if (context.overwrite) {\n      existing = void 0;\n    }\n    return merge(existing, incoming, makeFieldFunctionOptions(this,\n    // Unlike options.readField for read functions, we do not fall\n    // back to the current object if no foreignObjOrRef is provided,\n    // because it's not clear what the current object should be for\n    // merge functions: the (possibly undefined) existing object, or\n    // the incoming object? If you think your merge function needs\n    // to read sibling fields in order to produce a new value for\n    // the current field, you might want to rethink your strategy,\n    // because that's a recipe for making merge behavior sensitive\n    // to the order in which fields are written into the cache.\n    // However, readField(name, ref) is useful for merge functions\n    // that need to deduplicate child objects and references.\n    void 0, {\n      typename: typename,\n      fieldName: field.name.value,\n      field: field,\n      variables: context.variables\n    }, context, storage || Object.create(null)));\n  };\n  return Policies;\n}();\nexport { Policies };\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n  var storeFieldName = policies.getStoreFieldName(fieldSpec);\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var variables = fieldSpec.variables || context.variables;\n  var _a = context.store,\n    toReference = _a.toReference,\n    canRead = _a.canRead;\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName: fieldName,\n    storeFieldName: storeFieldName,\n    variables: variables,\n    isReference: isReference,\n    toReference: toReference,\n    storage: storage,\n    cache: policies.cache,\n    canRead: canRead,\n    readField: function () {\n      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store)\n  };\n}\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n  var fieldNameOrOptions = readFieldArgs[0],\n    from = readFieldArgs[1],\n    argc = readFieldArgs.length;\n  var options;\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      // Default to objectOrReference only when no second argument was\n      // passed for the from parameter, not when undefined is explicitly\n      // passed as the second argument.\n      from: argc > 1 ? from : objectOrReference\n    };\n  } else {\n    options = __assign({}, fieldNameOrOptions);\n    // Default to objectOrReference only when fieldNameOrOptions.from is\n    // actually omitted, rather than just undefined.\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n  if (globalThis.__DEV__ !== false && options.from === void 0) {\n    globalThis.__DEV__ !== false && invariant.warn(8, stringifyForDisplay(Array.from(readFieldArgs)));\n  }\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n  return options;\n}\nfunction makeMergeObjectsFunction(store) {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw newInvariantError(9);\n    }\n    // These dynamic checks are necessary because the parameters of a\n    // custom merge function can easily have the any type, so the type\n    // system cannot always enforce the StoreObject | Reference parameter\n    // types of options.mergeObjects.\n    if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n      var eType = store.getFieldValue(existing, \"__typename\");\n      var iType = store.getFieldValue(incoming, \"__typename\");\n      var typesDiffer = eType && iType && eType !== iType;\n      if (typesDiffer) {\n        return incoming;\n      }\n      if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // existing.__ref, preferring/overwriting any fields contributed by the\n        // newer incoming StoreObject.\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n      if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // incoming.__ref, taking fields from the older existing object only if\n        // those fields are not already present in the newer StoreObject\n        // identified by incoming.__ref.\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {\n        return __assign(__assign({}, existing), incoming);\n      }\n    }\n    return incoming;\n  };\n}\n", "import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport { Kind } from \"graphql\";\nimport { getFragmentFromSelection, getDefaultValues, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument, isNonEmptyArray, argumentsObjectFromField, canonicalStringify } from \"../../utilities/index.js\";\nimport { isArray, makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, extractFragmentContext } from \"./helpers.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\n// Since there are only four possible combinations of context.clientOnly and\n// context.deferred values, we should need at most four \"flavors\" of any given\n// WriteContext. To avoid creating multiple copies of the same context, we cache\n// the contexts in the context.flavors Map (shared by all flavors) according to\n// their clientOnly and deferred values (always in that order).\nfunction getContextFlavor(context, clientOnly, deferred) {\n  var key = \"\".concat(clientOnly).concat(deferred);\n  var flavored = context.flavors.get(key);\n  if (!flavored) {\n    context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign(__assign({}, context), {\n      clientOnly: clientOnly,\n      deferred: deferred\n    }));\n  }\n  return flavored;\n}\nvar StoreWriter = /** @class */function () {\n  function StoreWriter(cache, reader, fragments) {\n    this.cache = cache;\n    this.reader = reader;\n    this.fragments = fragments;\n  }\n  StoreWriter.prototype.writeToStore = function (store, _a) {\n    var _this = this;\n    var query = _a.query,\n      result = _a.result,\n      dataId = _a.dataId,\n      variables = _a.variables,\n      overwrite = _a.overwrite;\n    var operationDefinition = getOperationDefinition(query);\n    var merger = makeProcessedFieldsMerger();\n    variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n    var context = __assign(__assign({\n      store: store,\n      written: Object.create(null),\n      merge: function (existing, incoming) {\n        return merger.merge(existing, incoming);\n      },\n      variables: variables,\n      varString: canonicalStringify(variables)\n    }, extractFragmentContext(query, this.fragments)), {\n      overwrite: !!overwrite,\n      incomingById: new Map(),\n      clientOnly: false,\n      deferred: false,\n      flavors: new Map()\n    });\n    var ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId: dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: {\n        map: new Map()\n      },\n      context: context\n    });\n    if (!isReference(ref)) {\n      throw newInvariantError(12, result);\n    }\n    // So far, the store has not been modified, so now it's time to process\n    // context.incomingById and merge those incoming fields into context.store.\n    context.incomingById.forEach(function (_a, dataId) {\n      var storeObject = _a.storeObject,\n        mergeTree = _a.mergeTree,\n        fieldNodeSet = _a.fieldNodeSet;\n      var entityRef = makeReference(dataId);\n      if (mergeTree && mergeTree.map.size) {\n        var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n        if (isReference(applied)) {\n          // Assume References returned by applyMerges have already been merged\n          // into the store. See makeMergeObjectsFunction in policies.ts for an\n          // example of how this can happen.\n          return;\n        }\n        // Otherwise, applyMerges returned a StoreObject, whose fields we should\n        // merge into the store (see store.merge statement below).\n        storeObject = applied;\n      }\n      if (globalThis.__DEV__ !== false && !context.overwrite) {\n        var fieldsWithSelectionSets_1 = Object.create(null);\n        fieldNodeSet.forEach(function (field) {\n          if (field.selectionSet) {\n            fieldsWithSelectionSets_1[field.name.value] = true;\n          }\n        });\n        var hasSelectionSet_1 = function (storeFieldName) {\n          return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;\n        };\n        var hasMergeFunction_1 = function (storeFieldName) {\n          var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n          return Boolean(childTree && childTree.info && childTree.info.merge);\n        };\n        Object.keys(storeObject).forEach(function (storeFieldName) {\n          // If a merge function was defined for this field, trust that it\n          // did the right thing about (not) clobbering data. If the field\n          // has no selection set, it's a scalar field, so it doesn't need\n          // a merge function (even if it's an object, like JSON data).\n          if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {\n            warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n          }\n        });\n      }\n      store.merge(dataId, storeObject);\n    });\n    // Any IDs written explicitly to the cache will be retained as\n    // reachable root IDs for garbage collection purposes. Although this\n    // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n    // retainment counts are effectively ignored because cache.gc() always\n    // includes them in its root ID set.\n    store.retain(ref.__ref);\n    return ref;\n  };\n  StoreWriter.prototype.processSelectionSet = function (_a) {\n    var _this = this;\n    var dataId = _a.dataId,\n      result = _a.result,\n      selectionSet = _a.selectionSet,\n      context = _a.context,\n      // This object allows processSelectionSet to report useful information\n      // to its callers without explicitly returning that information.\n      mergeTree = _a.mergeTree;\n    var policies = this.cache.policies;\n    // This variable will be repeatedly updated using context.merge to\n    // accumulate all fields that need to be written into the store.\n    var incoming = Object.create(null);\n    // If typename was not passed in, infer it. Note that typename is\n    // always passed in for tricky-to-infer cases such as \"Query\" for\n    // ROOT_QUERY.\n    var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, \"__typename\");\n    if (\"string\" === typeof typename) {\n      incoming.__typename = typename;\n    }\n    // This readField function will be passed as context.readField in the\n    // KeyFieldsContext object created within policies.identify (called below).\n    // In addition to reading from the existing context.store (thanks to the\n    // policies.readField(options, context) line at the very bottom), this\n    // version of readField can read from Reference objects that are currently\n    // pending in context.incomingById, which is important whenever keyFields\n    // need to be extracted from a child object that processSelectionSet has\n    // turned into a Reference.\n    var readField = function () {\n      var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\n      if (isReference(options.from)) {\n        var info = context.incomingById.get(options.from.__ref);\n        if (info) {\n          var result_1 = policies.readField(__assign(__assign({}, options), {\n            from: info.storeObject\n          }), context);\n          if (result_1 !== void 0) {\n            return result_1;\n          }\n        }\n      }\n      return policies.readField(options, context);\n    };\n    var fieldNodeSet = new Set();\n    this.flattenFields(selectionSet, result,\n    // This WriteContext will be the default context value for fields returned\n    // by the flattenFields method, but some fields may be assigned a modified\n    // context, depending on the presence of @client and other directives.\n    context, typename).forEach(function (context, field) {\n      var _a;\n      var resultFieldKey = resultKeyNameFromField(field);\n      var value = result[resultFieldKey];\n      fieldNodeSet.add(field);\n      if (value !== void 0) {\n        var storeFieldName = policies.getStoreFieldName({\n          typename: typename,\n          fieldName: field.name.value,\n          field: field,\n          variables: context.variables\n        });\n        var childTree = getChildMergeTree(mergeTree, storeFieldName);\n        var incomingValue = _this.processFieldValue(value, field,\n        // Reset context.clientOnly and context.deferred to their default\n        // values before processing nested selection sets.\n        field.selectionSet ? getContextFlavor(context, false, false) : context, childTree);\n        // To determine if this field holds a child object with a merge function\n        // defined in its type policy (see PR #7070), we need to figure out the\n        // child object's __typename.\n        var childTypename = void 0;\n        // The field's value can be an object that has a __typename only if the\n        // field has a selection set. Otherwise incomingValue is scalar.\n        if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {\n          childTypename = readField(\"__typename\", incomingValue);\n        }\n        var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n        if (merge) {\n          childTree.info = {\n            // TODO Check compatibility against any existing childTree.field?\n            field: field,\n            typename: typename,\n            merge: merge\n          };\n        } else {\n          maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n        }\n        incoming = context.merge(incoming, (_a = {}, _a[storeFieldName] = incomingValue, _a));\n      } else if (globalThis.__DEV__ !== false && !context.clientOnly && !context.deferred && !addTypenameToDocument.added(field) &&\n      // If the field has a read function, it may be a synthetic field or\n      // provide a default value, so its absence from the written data should\n      // not be cause for alarm.\n      !policies.getReadFunction(typename, field.name.value)) {\n        globalThis.__DEV__ !== false && invariant.error(13, resultKeyNameFromField(field), result);\n      }\n    });\n    // Identify the result object, even if dataId was already provided,\n    // since we always need keyObject below.\n    try {\n      var _b = policies.identify(result, {\n          typename: typename,\n          selectionSet: selectionSet,\n          fragmentMap: context.fragmentMap,\n          storeObject: incoming,\n          readField: readField\n        }),\n        id = _b[0],\n        keyObject = _b[1];\n      // If dataId was not provided, fall back to the id just generated by\n      // policies.identify.\n      dataId = dataId || id;\n      // Write any key fields that were used during identification, even if\n      // they were not mentioned in the original query.\n      if (keyObject) {\n        // TODO Reverse the order of the arguments?\n        incoming = context.merge(incoming, keyObject);\n      }\n    } catch (e) {\n      // If dataId was provided, tolerate failure of policies.identify.\n      if (!dataId) throw e;\n    }\n    if (\"string\" === typeof dataId) {\n      var dataRef = makeReference(dataId);\n      // Avoid processing the same entity object using the same selection\n      // set more than once. We use an array instead of a Set since most\n      // entity IDs will be written using only one selection set, so the\n      // size of this array is likely to be very small, meaning indexOf is\n      // likely to be faster than Set.prototype.has.\n      var sets = context.written[dataId] || (context.written[dataId] = []);\n      if (sets.indexOf(selectionSet) >= 0) return dataRef;\n      sets.push(selectionSet);\n      // If we're about to write a result object into the store, but we\n      // happen to know that the exact same (===) result object would be\n      // returned if we were to reread the result with the same inputs,\n      // then we can skip the rest of the processSelectionSet work for\n      // this object, and immediately return a Reference to it.\n      if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {\n        return dataRef;\n      }\n      var previous_1 = context.incomingById.get(dataId);\n      if (previous_1) {\n        previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n        previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n        fieldNodeSet.forEach(function (field) {\n          return previous_1.fieldNodeSet.add(field);\n        });\n      } else {\n        context.incomingById.set(dataId, {\n          storeObject: incoming,\n          // Save a reference to mergeTree only if it is not empty, because\n          // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n          // reused for entirely different parts of the result tree.\n          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n          fieldNodeSet: fieldNodeSet\n        });\n      }\n      return dataRef;\n    }\n    return incoming;\n  };\n  StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\n    var _this = this;\n    if (!field.selectionSet || value === null) {\n      // In development, we need to clone scalar values so that they can be\n      // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n      // it's cheaper to store the scalar values directly in the cache.\n      return globalThis.__DEV__ !== false ? cloneDeep(value) : value;\n    }\n    if (isArray(value)) {\n      return value.map(function (item, i) {\n        var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context: context,\n      mergeTree: mergeTree\n    });\n  };\n  // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\n  // some additions for tracking @client and @defer directives.\n  StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {\n    if (typename === void 0) {\n      typename = getTypenameFromResult(result, selectionSet, context.fragmentMap);\n    }\n    var fieldMap = new Map();\n    var policies = this.cache.policies;\n    var limitingTrie = new Trie(false); // No need for WeakMap, since limitingTrie does not escape.\n    (function flatten(selectionSet, inheritedContext) {\n      var visitedNode = limitingTrie.lookup(selectionSet,\n      // Because we take inheritedClientOnly and inheritedDeferred into\n      // consideration here (in addition to selectionSet), it's possible for\n      // the same selection set to be flattened more than once, if it appears\n      // in the query with different @client and/or @directive configurations.\n      inheritedContext.clientOnly, inheritedContext.deferred);\n      if (visitedNode.visited) return;\n      visitedNode.visited = true;\n      selectionSet.selections.forEach(function (selection) {\n        if (!shouldInclude(selection, context.variables)) return;\n        var clientOnly = inheritedContext.clientOnly,\n          deferred = inheritedContext.deferred;\n        if (\n        // Since the presence of @client or @defer on this field can only\n        // cause clientOnly or deferred to become true, we can skip the\n        // forEach loop if both clientOnly and deferred are already true.\n        !(clientOnly && deferred) && isNonEmptyArray(selection.directives)) {\n          selection.directives.forEach(function (dir) {\n            var name = dir.name.value;\n            if (name === \"client\") clientOnly = true;\n            if (name === \"defer\") {\n              var args = argumentsObjectFromField(dir, context.variables);\n              // The @defer directive takes an optional args.if boolean\n              // argument, similar to @include(if: boolean). Note that\n              // @defer(if: false) does not make context.deferred false, but\n              // instead behaves as if there was no @defer directive.\n              if (!args || args.if !== false) {\n                deferred = true;\n              }\n              // TODO In the future, we may want to record args.label using\n              // context.deferred, if a label is specified.\n            }\n          });\n        }\n        if (isField(selection)) {\n          var existing = fieldMap.get(selection);\n          if (existing) {\n            // If this field has been visited along another recursive path\n            // before, the final context should have clientOnly or deferred set\n            // to true only if *all* paths have the directive (hence the &&).\n            clientOnly = clientOnly && existing.clientOnly;\n            deferred = deferred && existing.deferred;\n          }\n          fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n        } else {\n          var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n            throw newInvariantError(14, selection.name.value);\n          }\n          if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {\n            flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n          }\n        }\n      });\n    })(selectionSet, context);\n    return fieldMap;\n  };\n  StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\n    var _a;\n    var _this = this;\n    if (mergeTree.map.size && !isReference(incoming)) {\n      var e_1 =\n      // Items in the same position in different arrays are not\n      // necessarily related to each other, so when incoming is an array\n      // we process its elements as if there was no existing data.\n      !isArray(incoming) && (\n      // Likewise, existing must be either a Reference or a StoreObject\n      // in order for its fields to be safe to merge with the fields of\n      // the incoming object.\n      isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0;\n      // This narrowing is implied by mergeTree.map.size > 0 and\n      // !isReference(incoming), though TypeScript understandably cannot\n      // hope to infer this type.\n      var i_1 = incoming;\n      // The options.storage objects provided to read and merge functions\n      // are derived from the identity of the parent object plus a\n      // sequence of storeFieldName strings/numbers identifying the nested\n      // field name path of each field value to be merged.\n      if (e_1 && !getStorageArgs) {\n        getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\n      }\n      // It's possible that applying merge functions to this subtree will\n      // not change the incoming data, so this variable tracks the fields\n      // that did change, so we can create a new incoming object when (and\n      // only when) at least one incoming field has changed. We use a Map\n      // to preserve the type of numeric keys.\n      var changedFields_1;\n      var getValue_1 = function (from, name) {\n        return isArray(from) ? typeof name === \"number\" ? from[name] : void 0 : context.store.getFieldValue(from, String(name));\n      };\n      mergeTree.map.forEach(function (childTree, storeFieldName) {\n        var eVal = getValue_1(e_1, storeFieldName);\n        var iVal = getValue_1(i_1, storeFieldName);\n        // If we have no incoming data, leave any existing data untouched.\n        if (void 0 === iVal) return;\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n        var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n        if (aVal !== iVal) {\n          changedFields_1 = changedFields_1 || new Map();\n          changedFields_1.set(storeFieldName, aVal);\n        }\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n      if (changedFields_1) {\n        // Shallow clone i so we can add changed fields to it.\n        incoming = isArray(i_1) ? i_1.slice(0) : __assign({}, i_1);\n        changedFields_1.forEach(function (value, name) {\n          incoming[name] = value;\n        });\n      }\n    }\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n    }\n    return incoming;\n  };\n  return StoreWriter;\n}();\nexport { StoreWriter };\nvar emptyMergeTreePool = [];\nfunction getChildMergeTree(_a, name) {\n  var map = _a.map;\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || {\n      map: new Map()\n    });\n  }\n  return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n  if (left === right || !right || mergeTreeIsEmpty(right)) return left;\n  if (!left || mergeTreeIsEmpty(left)) return right;\n  var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\n  var needToMergeMaps = left.map.size && right.map.size;\n  var map = needToMergeMaps ? new Map() : left.map.size ? left.map : right.map;\n  var merged = {\n    info: info,\n    map: map\n  };\n  if (needToMergeMaps) {\n    var remainingRightKeys_1 = new Set(right.map.keys());\n    left.map.forEach(function (leftTree, key) {\n      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n      remainingRightKeys_1.delete(key);\n    });\n    remainingRightKeys_1.forEach(function (key) {\n      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n    });\n  }\n  return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n  return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree(_a, name) {\n  var map = _a.map;\n  var childTree = map.get(name);\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\nvar warnings = new Set();\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n  var getChild = function (objOrRef) {\n    var child = store.getFieldValue(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n  var existing = getChild(existingRef);\n  if (!existing) return;\n  var incoming = getChild(incomingObj);\n  if (!incoming) return;\n  // It's always safe to replace a reference, since it refers to data\n  // safely stored elsewhere.\n  if (isReference(existing)) return;\n  // If the values are structurally equivalent, we do not need to worry\n  // about incoming replacing existing.\n  if (equal(existing, incoming)) return;\n  // If we're replacing every key of the existing object, then the\n  // existing data would be overwritten even if the objects were\n  // normalized, so warning would not be helpful here.\n  if (Object.keys(existing).every(function (key) {\n    return store.getFieldValue(incoming, key) !== void 0;\n  })) {\n    return;\n  }\n  var parentType = store.getFieldValue(existingRef, \"__typename\") || store.getFieldValue(incomingObj, \"__typename\");\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n  // Avoid warning more than once for the same type and field name.\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n  var childTypenames = [];\n  // Arrays do not have __typename fields, and always need a custom merge\n  // function, even if their elements are normalized entities.\n  if (!isArray(existing) && !isArray(incoming)) {\n    [existing, incoming].forEach(function (child) {\n      var typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n  globalThis.__DEV__ !== false && invariant.warn(15, fieldName, parentType, childTypenames.length ? \"either ensure all objects of type \" + childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \" : \"\", typeDotName, __assign({}, existing), __assign({}, incoming));\n}\n", "import { __assign, __extends } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\n// Make builtins like Map and Set safe to use with non-extensible objects.\nimport \"./fixPolyfills.js\";\nimport { wrap } from \"optimism\";\nimport { equal } from \"@wry/equality\";\nimport { ApolloCache } from \"../core/cache.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { addTypenameToDocument, isReference, DocumentTransform, canonicalStringify, print, cacheSizes } from \"../../utilities/index.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { makeVar, forgetCache, recallCache } from \"./reactiveVars.js\";\nimport { Policies } from \"./policies.js\";\nimport { hasOwn, normalizeConfig, shouldCanonizeResults } from \"./helpers.js\";\nimport { getInMemoryCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\nvar InMemoryCache = /** @class */function (_super) {\n  __extends(InMemoryCache, _super);\n  function InMemoryCache(config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var _this = _super.call(this) || this;\n    _this.watches = new Set();\n    _this.addTypenameTransform = new DocumentTransform(addTypenameToDocument);\n    // Override the default value, since InMemoryCache result objects are frozen\n    // in development and expected to remain logically immutable in production.\n    _this.assumeImmutableResults = true;\n    _this.makeVar = makeVar;\n    _this.txCount = 0;\n    _this.config = normalizeConfig(config);\n    _this.addTypename = !!_this.config.addTypename;\n    _this.policies = new Policies({\n      cache: _this,\n      dataIdFromObject: _this.config.dataIdFromObject,\n      possibleTypes: _this.config.possibleTypes,\n      typePolicies: _this.config.typePolicies\n    });\n    _this.init();\n    return _this;\n  }\n  InMemoryCache.prototype.init = function () {\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    var rootStore = this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching\n    });\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of EntityStore Layer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = rootStore.stump;\n    this.resetResultCache();\n  };\n  InMemoryCache.prototype.resetResultCache = function (resetResultIdentities) {\n    var _this = this;\n    var previousReader = this.storeReader;\n    var fragments = this.config.fragments;\n    // The StoreWriter is mostly stateless and so doesn't really need to be\n    // reset, but it does need to have its writer.storeReader reference updated,\n    // so it's simpler to update this.storeWriter as well.\n    this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({\n      cache: this,\n      addTypename: this.addTypename,\n      resultCacheMaxSize: this.config.resultCacheMaxSize,\n      canonizeResults: shouldCanonizeResults(this.config),\n      canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,\n      fragments: fragments\n    }), fragments);\n    this.maybeBroadcastWatch = wrap(function (c, options) {\n      return _this.broadcastWatch(c, options);\n    }, {\n      max: this.config.resultCacheMaxSize || cacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] || 5000 /* defaultCacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] */,\n      makeCacheKey: function (c) {\n        // Return a cache key (thus enabling result caching) only if we're\n        // currently using a data store that can track cache dependencies.\n        var store = c.optimistic ? _this.optimisticData : _this.data;\n        if (supportsResultCaching(store)) {\n          var optimistic = c.optimistic,\n            id = c.id,\n            variables = c.variables;\n          return store.makeCacheKey(c.query,\n          // Different watches can have the same query, optimistic\n          // status, rootId, and variables, but if their callbacks are\n          // different, the (identical) result needs to be delivered to\n          // each distinct callback. The easiest way to achieve that\n          // separation is to include c.callback in the cache key for\n          // maybeBroadcastWatch calls. See issue #5733.\n          c.callback, canonicalStringify({\n            optimistic: optimistic,\n            id: id,\n            variables: variables\n          }));\n        }\n      }\n    });\n    // Since we have thrown away all the cached functions that depend on the\n    // CacheGroup dependencies maintained by EntityStore, we should also reset\n    // all CacheGroup dependency information.\n    new Set([this.data.group, this.optimisticData.group]).forEach(function (group) {\n      return group.resetCaching();\n    });\n  };\n  InMemoryCache.prototype.restore = function (data) {\n    this.init();\n    // Since calling this.init() discards/replaces the entire StoreReader, along\n    // with the result caches it maintains, this.data.replace(data) won't have\n    // to bother deleting the old data.\n    if (data) this.data.replace(data);\n    return this;\n  };\n  InMemoryCache.prototype.extract = function (optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n    return (optimistic ? this.optimisticData : this.data).extract();\n  };\n  InMemoryCache.prototype.read = function (options) {\n    var\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      _a = options.returnPartialData,\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      returnPartialData = _a === void 0 ? false : _a;\n    try {\n      return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), {\n        store: options.optimistic ? this.optimisticData : this.data,\n        config: this.config,\n        returnPartialData: returnPartialData\n      })).result || null;\n    } catch (e) {\n      if (e instanceof MissingFieldError) {\n        // Swallow MissingFieldError and return null, so callers do not need to\n        // worry about catching \"normal\" exceptions resulting from incomplete\n        // cache data. Unexpected errors will be re-thrown. If you need more\n        // information about which fields were missing, use cache.diff instead,\n        // and examine diffResult.missing.\n        return null;\n      }\n      throw e;\n    }\n  };\n  InMemoryCache.prototype.write = function (options) {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore(this.data, options);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  };\n  InMemoryCache.prototype.modify = function (options) {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      // To my knowledge, TypeScript does not currently provide a way to\n      // enforce that an optional property?:type must *not* be undefined\n      // when present. That ability would be useful here, because we want\n      // options.id to default to ROOT_QUERY only when no options.id was\n      // provided. If the caller attempts to pass options.id with a\n      // falsy/undefined value (perhaps because cache.identify failed), we\n      // should not assume the goal was to modify the ROOT_QUERY object.\n      // We could throw, but it seems natural to return false to indicate\n      // that nothing was modified.\n      return false;\n    }\n    var store = options.optimistic // Defaults to false.\n    ? this.optimisticData : this.data;\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  };\n  InMemoryCache.prototype.diff = function (options) {\n    return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), {\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      config: this.config\n    }));\n  };\n  InMemoryCache.prototype.watch = function (watch) {\n    var _this = this;\n    if (!this.watches.size) {\n      // In case we previously called forgetCache(this) because\n      // this.watches became empty (see below), reattach this cache to any\n      // reactive variables on which it previously depended. It might seem\n      // paradoxical that we're able to recall something we supposedly\n      // forgot, but the point of calling forgetCache(this) is to silence\n      // useless broadcasts while this.watches is empty, and to allow the\n      // cache to be garbage collected. If, however, we manage to call\n      // recallCache(this) here, this cache object must not have been\n      // garbage collected yet, and should resume receiving updates from\n      // reactive variables, now that it has a watcher to notify.\n      recallCache(this);\n    }\n    this.watches.add(watch);\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n    return function () {\n      // Once we remove the last watch from this.watches, cache.broadcastWatches\n      // no longer does anything, so we preemptively tell the reactive variable\n      // system to exclude this cache from future broadcasts.\n      if (_this.watches.delete(watch) && !_this.watches.size) {\n        forgetCache(_this);\n      }\n      // Remove this watch from the LRU cache managed by the\n      // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n      // leaks involving the closure of watch.callback.\n      _this.maybeBroadcastWatch.forget(watch);\n    };\n  };\n  InMemoryCache.prototype.gc = function (options) {\n    var _a;\n    canonicalStringify.reset();\n    print.reset();\n    this.addTypenameTransform.resetCache();\n    (_a = this.config.fragments) === null || _a === void 0 ? void 0 : _a.resetCaches();\n    var ids = this.optimisticData.gc();\n    if (options && !this.txCount) {\n      if (options.resetResultCache) {\n        this.resetResultCache(options.resetResultIdentities);\n      } else if (options.resetResultIdentities) {\n        this.storeReader.resetCanon();\n      }\n    }\n    return ids;\n  };\n  // Call this method to ensure the given root ID remains in the cache after\n  // garbage collection, along with its transitive child entities. Note that\n  // the cache automatically retains all directly written entities. By default,\n  // the retainment persists after optimistic updates are removed. Pass true\n  // for the optimistic argument if you would prefer for the retainment to be\n  // discarded when the top-most optimistic layer is removed. Returns the\n  // resulting (non-negative) retainment count.\n  InMemoryCache.prototype.retain = function (rootId, optimistic) {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  };\n  // Call this method to undo the effect of the retain method, above. Once the\n  // retainment count falls to zero, the given ID will no longer be preserved\n  // during garbage collection, though it may still be preserved by other safe\n  // entities that refer to it. Returns the resulting (non-negative) retainment\n  // count, in case that's useful.\n  InMemoryCache.prototype.release = function (rootId, optimistic) {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  };\n  // Returns the canonical ID for a given StoreObject, obeying typePolicies\n  // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n  // the object must contain a __typename and any primary key fields required\n  // to identify entities of that type. If you pass a query result object, be\n  // sure that none of the primary key fields have been renamed by aliasing.\n  // If you pass a Reference object, its __ref ID string will be returned.\n  InMemoryCache.prototype.identify = function (object) {\n    if (isReference(object)) return object.__ref;\n    try {\n      return this.policies.identify(object)[0];\n    } catch (e) {\n      globalThis.__DEV__ !== false && invariant.warn(e);\n    }\n  };\n  InMemoryCache.prototype.evict = function (options) {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        // See comment in modify method about why we return false when\n        // options.id exists but is falsy/undefined.\n        return false;\n      }\n      options = __assign(__assign({}, options), {\n        id: \"ROOT_QUERY\"\n      });\n    }\n    try {\n      // It's unlikely that the eviction will end up invoking any other\n      // cache update operations while it's running, but {in,de}crementing\n      // this.txCount still seems like a good idea, for uniformity with\n      // the other update methods.\n      ++this.txCount;\n      // Pass this.data as a limit on the depth of the eviction, so evictions\n      // during optimistic updates (when this.data is temporarily set equal to\n      // this.optimisticData) do not escape their optimistic Layer.\n      return this.optimisticData.evict(options, this.data);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  };\n  InMemoryCache.prototype.reset = function (options) {\n    var _this = this;\n    this.init();\n    canonicalStringify.reset();\n    if (options && options.discardWatches) {\n      // Similar to what happens in the unsubscribe function returned by\n      // cache.watch, applied to all current watches.\n      this.watches.forEach(function (watch) {\n        return _this.maybeBroadcastWatch.forget(watch);\n      });\n      this.watches.clear();\n      forgetCache(this);\n    } else {\n      // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n      // this.broadcastWatches() triggers a broadcast to every current watcher\n      // (letting them know their data is now missing). This default behavior is\n      // convenient because it means the watches do not have to be manually\n      // reestablished after resetting the cache. To prevent this broadcast and\n      // cancel all watches, pass true for options.discardWatches.\n      this.broadcastWatches();\n    }\n    return Promise.resolve();\n  };\n  InMemoryCache.prototype.removeOptimistic = function (idToRemove) {\n    var newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  };\n  InMemoryCache.prototype.batch = function (options) {\n    var _this = this;\n    var update = options.update,\n      _a = options.optimistic,\n      optimistic = _a === void 0 ? true : _a,\n      removeOptimistic = options.removeOptimistic,\n      onWatchUpdated = options.onWatchUpdated;\n    var updateResult;\n    var perform = function (layer) {\n      var _a = _this,\n        data = _a.data,\n        optimisticData = _a.optimisticData;\n      ++_this.txCount;\n      if (layer) {\n        _this.data = _this.optimisticData = layer;\n      }\n      try {\n        return updateResult = update(_this);\n      } finally {\n        --_this.txCount;\n        _this.data = data;\n        _this.optimisticData = optimisticData;\n      }\n    };\n    var alreadyDirty = new Set();\n    if (onWatchUpdated && !this.txCount) {\n      // If an options.onWatchUpdated callback is provided, we want to call it\n      // with only the Cache.WatchOptions objects affected by options.update,\n      // but there might be dirty watchers already waiting to be broadcast that\n      // have nothing to do with the update. To prevent including those watchers\n      // in the post-update broadcast, we perform this initial broadcast to\n      // collect the dirty watchers, so we can re-dirty them later, after the\n      // post-update broadcast, allowing them to receive their pending\n      // broadcasts the next time broadcastWatches is called, just as they would\n      // if we never called cache.batch.\n      this.broadcastWatches(__assign(__assign({}, options), {\n        onWatchUpdated: function (watch) {\n          alreadyDirty.add(watch);\n          return false;\n        }\n      }));\n    }\n    if (typeof optimistic === \"string\") {\n      // Note that there can be multiple layers with the same optimistic ID.\n      // When removeOptimistic(id) is called for that id, all matching layers\n      // will be removed, and the remaining layers will be reapplied.\n      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n    } else if (optimistic === false) {\n      // Ensure both this.data and this.optimisticData refer to the root\n      // (non-optimistic) layer of the cache during the update. Note that\n      // this.data could be a Layer if we are currently executing an optimistic\n      // update function, but otherwise will always be an EntityStore.Root\n      // instance.\n      perform(this.data);\n    } else {\n      // Otherwise, leave this.data and this.optimisticData unchanged and run\n      // the update with broadcast batching.\n      perform();\n    }\n    if (typeof removeOptimistic === \"string\") {\n      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n    }\n    // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n    // takes the else branch and calls this.broadcastWatches(options), which\n    // does nothing when this.txCount > 0.\n    if (onWatchUpdated && alreadyDirty.size) {\n      this.broadcastWatches(__assign(__assign({}, options), {\n        onWatchUpdated: function (watch, diff) {\n          var result = onWatchUpdated.call(this, watch, diff);\n          if (result !== false) {\n            // Since onWatchUpdated did not return false, this diff is\n            // about to be broadcast to watch.callback, so we don't need\n            // to re-dirty it with the other alreadyDirty watches below.\n            alreadyDirty.delete(watch);\n          }\n          return result;\n        }\n      }));\n      // Silently re-dirty any watches that were already dirty before the update\n      // was performed, and were not broadcast just now.\n      if (alreadyDirty.size) {\n        alreadyDirty.forEach(function (watch) {\n          return _this.maybeBroadcastWatch.dirty(watch);\n        });\n      }\n    } else {\n      // If alreadyDirty is empty or we don't have an onWatchUpdated\n      // function, we don't need to go to the trouble of wrapping\n      // options.onWatchUpdated.\n      this.broadcastWatches(options);\n    }\n    return updateResult;\n  };\n  InMemoryCache.prototype.performTransaction = function (update, optimisticId) {\n    return this.batch({\n      update: update,\n      optimistic: optimisticId || optimisticId !== null\n    });\n  };\n  InMemoryCache.prototype.transformDocument = function (document) {\n    return this.addTypenameToDocument(this.addFragmentsToDocument(document));\n  };\n  InMemoryCache.prototype.fragmentMatches = function (fragment, typename) {\n    return this.policies.fragmentMatches(fragment, typename);\n  };\n  InMemoryCache.prototype.lookupFragment = function (fragmentName) {\n    var _a;\n    return ((_a = this.config.fragments) === null || _a === void 0 ? void 0 : _a.lookup(fragmentName)) || null;\n  };\n  InMemoryCache.prototype.broadcastWatches = function (options) {\n    var _this = this;\n    if (!this.txCount) {\n      this.watches.forEach(function (c) {\n        return _this.maybeBroadcastWatch(c, options);\n      });\n    }\n  };\n  InMemoryCache.prototype.addFragmentsToDocument = function (document) {\n    var fragments = this.config.fragments;\n    return fragments ? fragments.transform(document) : document;\n  };\n  InMemoryCache.prototype.addTypenameToDocument = function (document) {\n    if (this.addTypename) {\n      return this.addTypenameTransform.transformDocument(document);\n    }\n    return document;\n  };\n  // This method is wrapped by maybeBroadcastWatch, which is called by\n  // broadcastWatches, so that we compute and broadcast results only when\n  // the data that would be broadcast might have changed. It would be\n  // simpler to check for changes after recomputing a result but before\n  // broadcasting it, but this wrapping approach allows us to skip both\n  // the recomputation and the broadcast, in most cases.\n  InMemoryCache.prototype.broadcastWatch = function (c, options) {\n    var lastDiff = c.lastDiff;\n    // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n    // currently requires no additional properties, so we can use c (a\n    // WatchOptions object) as DiffOptions, without having to allocate a new\n    // object, and without having to enumerate the relevant properties (query,\n    // variables, etc.) explicitly. There will be some additional properties\n    // (lastDiff, callback, etc.), but cache.diff ignores them.\n    var diff = this.diff(c);\n    if (options) {\n      if (c.optimistic && typeof options.optimistic === \"string\") {\n        diff.fromOptimisticTransaction = true;\n      }\n      if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {\n        // Returning false from the onWatchUpdated callback will prevent\n        // calling c.callback(diff) for this watcher.\n        return;\n      }\n    }\n    if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n      c.callback(c.lastDiff = diff, lastDiff);\n    }\n  };\n  return InMemoryCache;\n}(ApolloCache);\nexport { InMemoryCache };\nif (globalThis.__DEV__ !== false) {\n  InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;\n}\n", "import { __assign, __spreadArray } from \"tslib\";\nimport { visit } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { cacheSizes, getFragmentDefinitions } from \"../../utilities/index.js\";\nimport { WeakCache } from \"@wry/caches\";\n// As long as createFragmentRegistry is not imported or used, the\n// FragmentRegistry example implementation provided below should not be bundled\n// (by tree-shaking bundlers like Rollup), because the implementation of\n// InMemoryCache refers only to the TypeScript interface FragmentRegistryAPI,\n// never the concrete implementation FragmentRegistry (which is deliberately not\n// exported from this module).\nexport function createFragmentRegistry() {\n  var fragments = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    fragments[_i] = arguments[_i];\n  }\n  return new (FragmentRegistry.bind.apply(FragmentRegistry, __spreadArray([void 0], fragments, false)))();\n}\nvar FragmentRegistry = /** @class */function () {\n  // Call `createFragmentRegistry` instead of invoking the\n  // FragmentRegistry constructor directly. This reserves the constructor for\n  // future configuration of the FragmentRegistry.\n  function FragmentRegistry() {\n    var fragments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      fragments[_i] = arguments[_i];\n    }\n    this.registry = Object.create(null);\n    this.resetCaches();\n    if (fragments.length) {\n      this.register.apply(this, fragments);\n    }\n  }\n  FragmentRegistry.prototype.register = function () {\n    var _this = this;\n    var fragments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      fragments[_i] = arguments[_i];\n    }\n    var definitions = new Map();\n    fragments.forEach(function (doc) {\n      getFragmentDefinitions(doc).forEach(function (node) {\n        definitions.set(node.name.value, node);\n      });\n    });\n    definitions.forEach(function (node, name) {\n      if (node !== _this.registry[name]) {\n        _this.registry[name] = node;\n        _this.invalidate(name);\n      }\n    });\n    return this;\n  };\n  // Overridden in the resetCaches method below.\n  FragmentRegistry.prototype.invalidate = function (name) {};\n  FragmentRegistry.prototype.resetCaches = function () {\n    var proto = FragmentRegistry.prototype;\n    this.invalidate = (this.lookup = wrap(proto.lookup.bind(this), {\n      makeCacheKey: function (arg) {\n        return arg;\n      },\n      max: cacheSizes[\"fragmentRegistry.lookup\"] || 1000 /* defaultCacheSizes[\"fragmentRegistry.lookup\"] */\n    })).dirty; // This dirty function is bound to the wrapped lookup method.\n    this.transform = wrap(proto.transform.bind(this), {\n      cache: WeakCache,\n      max: cacheSizes[\"fragmentRegistry.transform\"] || 2000 /* defaultCacheSizes[\"fragmentRegistry.transform\"] */\n    });\n    this.findFragmentSpreads = wrap(proto.findFragmentSpreads.bind(this), {\n      cache: WeakCache,\n      max: cacheSizes[\"fragmentRegistry.findFragmentSpreads\"] || 4000 /* defaultCacheSizes[\"fragmentRegistry.findFragmentSpreads\"] */\n    });\n  };\n  /*\n   * Note:\n   * This method is only memoized so it can serve as a dependency to `tranform`,\n   * so calling `invalidate` will invalidate cache entries for `transform`.\n   */\n  FragmentRegistry.prototype.lookup = function (fragmentName) {\n    return this.registry[fragmentName] || null;\n  };\n  FragmentRegistry.prototype.transform = function (document) {\n    var _this = this;\n    var defined = new Map();\n    getFragmentDefinitions(document).forEach(function (def) {\n      defined.set(def.name.value, def);\n    });\n    var unbound = new Set();\n    var enqueue = function (spreadName) {\n      if (!defined.has(spreadName)) {\n        unbound.add(spreadName);\n      }\n    };\n    var enqueueChildSpreads = function (node) {\n      return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue);\n    };\n    enqueueChildSpreads(document);\n    var missing = [];\n    var map = Object.create(null);\n    // This Set forEach loop can be extended during iteration by adding\n    // additional strings to the unbound set.\n    unbound.forEach(function (fragmentName) {\n      var knownFragmentDef = defined.get(fragmentName);\n      if (knownFragmentDef) {\n        enqueueChildSpreads(map[fragmentName] = knownFragmentDef);\n      } else {\n        missing.push(fragmentName);\n        var def = _this.lookup(fragmentName);\n        if (def) {\n          enqueueChildSpreads(map[fragmentName] = def);\n        }\n      }\n    });\n    if (missing.length) {\n      var defsToAppend_1 = [];\n      missing.forEach(function (name) {\n        var def = map[name];\n        if (def) {\n          defsToAppend_1.push(def);\n        }\n      });\n      if (defsToAppend_1.length) {\n        document = __assign(__assign({}, document), {\n          definitions: document.definitions.concat(defsToAppend_1)\n        });\n      }\n    }\n    return document;\n  };\n  FragmentRegistry.prototype.findFragmentSpreads = function (root) {\n    var spreads = Object.create(null);\n    visit(root, {\n      FragmentSpread: function (node) {\n        spreads[node.name.value] = node;\n      }\n    });\n    return spreads;\n  };\n  return FragmentRegistry;\n}();\n", "/**\n * The current status of a querys execution in our system.\n */\nexport var NetworkStatus;\n(function (NetworkStatus) {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  NetworkStatus[NetworkStatus[\"loading\"] = 1] = \"loading\";\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  NetworkStatus[NetworkStatus[\"setVariables\"] = 2] = \"setVariables\";\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  NetworkStatus[NetworkStatus[\"fetchMore\"] = 3] = \"fetchMore\";\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  NetworkStatus[NetworkStatus[\"refetch\"] = 4] = \"refetch\";\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  NetworkStatus[NetworkStatus[\"poll\"] = 6] = \"poll\";\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  NetworkStatus[NetworkStatus[\"ready\"] = 7] = \"ready\";\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  NetworkStatus[NetworkStatus[\"error\"] = 8] = \"error\";\n})(NetworkStatus || (NetworkStatus = {}));\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(networkStatus) {\n  return networkStatus ? networkStatus < 7 : false;\n}\n/**\n * Returns true if the network request is in ready or error state according to a given network\n * status.\n */\nexport function isNetworkRequestSettled(networkStatus) {\n  return networkStatus === 7 || networkStatus === 8;\n}\n", "import { __assign, __extends } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { cloneDeep, compact, getOperationDefinition, Observable, iterateObserversSafely, fixObservableSubclass, getQueryDefinition, preventUnhandledRejection } from \"../utilities/index.js\";\nimport { ApolloError, isApolloError } from \"../errors/index.js\";\nimport { equalByQuery } from \"./equalByQuery.js\";\nvar assign = Object.assign,\n  hasOwnProperty = Object.hasOwnProperty;\nvar ObservableQuery = /** @class */function (_super) {\n  __extends(ObservableQuery, _super);\n  function ObservableQuery(_a) {\n    var queryManager = _a.queryManager,\n      queryInfo = _a.queryInfo,\n      options = _a.options;\n    var _this = _super.call(this, function (observer) {\n      // Zen Observable has its own error function, so in order to log correctly\n      // we need to provide a custom error callback.\n      try {\n        var subObserver = observer._subscription._observer;\n        if (subObserver && !subObserver.error) {\n          subObserver.error = defaultSubscriptionObserverErrorCallback;\n        }\n      } catch (_a) {}\n      var first = !_this.observers.size;\n      _this.observers.add(observer);\n      // Deliver most recent error or result.\n      var last = _this.last;\n      if (last && last.error) {\n        observer.error && observer.error(last.error);\n      } else if (last && last.result) {\n        observer.next && observer.next(_this.maskResult(last.result));\n      }\n      // Initiate observation of this query if it hasn't been reported to\n      // the QueryManager yet.\n      if (first) {\n        // Blindly catching here prevents unhandled promise rejections,\n        // and is safe because the ObservableQuery handles this error with\n        // this.observer.error, so we're not just swallowing the error by\n        // ignoring it here.\n        _this.reobserve().catch(function () {});\n      }\n      return function () {\n        if (_this.observers.delete(observer) && !_this.observers.size) {\n          _this.tearDownQuery();\n        }\n      };\n    }) || this;\n    _this.observers = new Set();\n    _this.subscriptions = new Set();\n    // related classes\n    _this.queryInfo = queryInfo;\n    _this.queryManager = queryManager;\n    // active state\n    _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);\n    _this.isTornDown = false;\n    _this.subscribeToMore = _this.subscribeToMore.bind(_this);\n    _this.maskResult = _this.maskResult.bind(_this);\n    var _b = queryManager.defaultOptions.watchQuery,\n      _c = _b === void 0 ? {} : _b,\n      _d = _c.fetchPolicy,\n      defaultFetchPolicy = _d === void 0 ? \"cache-first\" : _d;\n    var _e = options.fetchPolicy,\n      fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e,\n      // Make sure we don't store \"standby\" as the initialFetchPolicy.\n      _f = options.initialFetchPolicy,\n      // Make sure we don't store \"standby\" as the initialFetchPolicy.\n      initialFetchPolicy = _f === void 0 ? fetchPolicy === \"standby\" ? defaultFetchPolicy : fetchPolicy : _f;\n    _this.options = __assign(__assign({}, options), {\n      // Remember the initial options.fetchPolicy so we can revert back to this\n      // policy when variables change. This information can also be specified\n      // (or overridden) by providing options.initialFetchPolicy explicitly.\n      initialFetchPolicy: initialFetchPolicy,\n      // This ensures this.options.fetchPolicy always has a string value, in\n      // case options.fetchPolicy was not provided.\n      fetchPolicy: fetchPolicy\n    });\n    _this.queryId = queryInfo.queryId || queryManager.generateQueryId();\n    var opDef = getOperationDefinition(_this.query);\n    _this.queryName = opDef && opDef.name && opDef.name.value;\n    return _this;\n  }\n  Object.defineProperty(ObservableQuery.prototype, \"query\", {\n    // The `query` computed property will always reflect the document transformed\n    // by the last run query. `this.options.query` will always reflect the raw\n    // untransformed query to ensure document transforms with runtime conditionals\n    // are run on the original document.\n    get: function () {\n      return this.lastQuery || this.options.query;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ObservableQuery.prototype, \"variables\", {\n    // Computed shorthand for this.options.variables, preserved for\n    // backwards compatibility.\n    /**\n     * An object containing the variables that were provided for the query.\n     */\n    get: function () {\n      return this.options.variables;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ObservableQuery.prototype.result = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      // TODO: this code doesnt actually make sense insofar as the observer\n      // will never exist in this.observers due how zen-observable wraps observables.\n      // https://github.com/zenparsing/zen-observable/blob/master/src/Observable.js#L169\n      var observer = {\n        next: function (result) {\n          resolve(result);\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          _this.observers.delete(observer);\n          if (!_this.observers.size) {\n            _this.queryManager.removeQuery(_this.queryId);\n          }\n          setTimeout(function () {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error: reject\n      };\n      var subscription = _this.subscribe(observer);\n    });\n  };\n  /** @internal */\n  ObservableQuery.prototype.resetDiff = function () {\n    this.queryInfo.resetDiff();\n  };\n  ObservableQuery.prototype.getCurrentFullResult = function (saveAsLastResult) {\n    if (saveAsLastResult === void 0) {\n      saveAsLastResult = true;\n    }\n    // Use the last result as long as the variables match this.variables.\n    var lastResult = this.getLastResult(true);\n    var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;\n    var result = __assign(__assign({}, lastResult), {\n      loading: isNetworkRequestInFlight(networkStatus),\n      networkStatus: networkStatus\n    });\n    var _a = this.options.fetchPolicy,\n      fetchPolicy = _a === void 0 ? \"cache-first\" : _a;\n    if (\n    // These fetch policies should never deliver data from the cache, unless\n    // redelivering a previously delivered result.\n    skipCacheDataFor(fetchPolicy) ||\n    // If this.options.query has @client(always: true) fields, we cannot\n    // trust diff.result, since it was read from the cache without running\n    // local resolvers (and it's too late to run resolvers now, since we must\n    // return a result synchronously).\n    this.queryManager.getDocumentInfo(this.query).hasForcedResolvers) {\n      // Fall through.\n    } else if (this.waitForOwnResult) {\n      // This would usually be a part of `QueryInfo.getDiff()`.\n      // which we skip in the waitForOwnResult case since we are not\n      // interested in the diff.\n      this.queryInfo[\"updateWatch\"]();\n    } else {\n      var diff = this.queryInfo.getDiff();\n      if (diff.complete || this.options.returnPartialData) {\n        result.data = diff.result;\n      }\n      if (equal(result.data, {})) {\n        result.data = void 0;\n      }\n      if (diff.complete) {\n        // Similar to setting result.partial to false, but taking advantage of the\n        // falsiness of missing fields.\n        delete result.partial;\n        // If the diff is complete, and we're using a FetchPolicy that\n        // terminates after a complete cache read, we can assume the next result\n        // we receive will have NetworkStatus.ready and !loading.\n        if (diff.complete && result.networkStatus === NetworkStatus.loading && (fetchPolicy === \"cache-first\" || fetchPolicy === \"cache-only\")) {\n          result.networkStatus = NetworkStatus.ready;\n          result.loading = false;\n        }\n      } else {\n        result.partial = true;\n      }\n      if (globalThis.__DEV__ !== false && !diff.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {\n        logMissingFieldErrors(diff.missing);\n      }\n    }\n    if (saveAsLastResult) {\n      this.updateLastResult(result);\n    }\n    return result;\n  };\n  ObservableQuery.prototype.getCurrentResult = function (saveAsLastResult) {\n    if (saveAsLastResult === void 0) {\n      saveAsLastResult = true;\n    }\n    return this.maskResult(this.getCurrentFullResult(saveAsLastResult));\n  };\n  // Compares newResult to the snapshot we took of this.lastResult when it was\n  // first received.\n  ObservableQuery.prototype.isDifferentFromLastResult = function (newResult, variables) {\n    if (!this.last) {\n      return true;\n    }\n    var documentInfo = this.queryManager.getDocumentInfo(this.query);\n    var dataMasking = this.queryManager.dataMasking;\n    var query = dataMasking ? documentInfo.nonReactiveQuery : this.query;\n    var resultIsDifferent = dataMasking || documentInfo.hasNonreactiveDirective ? !equalByQuery(query, this.last.result, newResult, this.variables) : !equal(this.last.result, newResult);\n    return resultIsDifferent || variables && !equal(this.last.variables, variables);\n  };\n  ObservableQuery.prototype.getLast = function (key, variablesMustMatch) {\n    var last = this.last;\n    if (last && last[key] && (!variablesMustMatch || equal(last.variables, this.variables))) {\n      return last[key];\n    }\n  };\n  ObservableQuery.prototype.getLastResult = function (variablesMustMatch) {\n    return this.getLast(\"result\", variablesMustMatch);\n  };\n  ObservableQuery.prototype.getLastError = function (variablesMustMatch) {\n    return this.getLast(\"error\", variablesMustMatch);\n  };\n  ObservableQuery.prototype.resetLastResults = function () {\n    delete this.last;\n    this.isTornDown = false;\n  };\n  ObservableQuery.prototype.resetQueryStoreErrors = function () {\n    this.queryManager.resetErrors(this.queryId);\n  };\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  ObservableQuery.prototype.refetch = function (variables) {\n    var _a;\n    var reobserveOptions = {\n      // Always disable polling for refetches.\n      pollInterval: 0\n    };\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    var fetchPolicy = this.options.fetchPolicy;\n    if (fetchPolicy === \"no-cache\") {\n      reobserveOptions.fetchPolicy = \"no-cache\";\n    } else {\n      reobserveOptions.fetchPolicy = \"network-only\";\n    }\n    if (globalThis.__DEV__ !== false && variables && hasOwnProperty.call(variables, \"variables\")) {\n      var queryDef = getQueryDefinition(this.query);\n      var vars = queryDef.variableDefinitions;\n      if (!vars || !vars.some(function (v) {\n        return v.variable.name.value === \"variables\";\n      })) {\n        globalThis.__DEV__ !== false && invariant.warn(21, variables, ((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || queryDef);\n      }\n    }\n    if (variables && !equal(this.options.variables, variables)) {\n      // Update the existing options with new variables\n      reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);\n    }\n    this.queryInfo.resetLastWrite();\n    return this.reobserve(reobserveOptions, NetworkStatus.refetch);\n  };\n  /**\n   * A function that helps you fetch the next set of results for a [paginated list field](https://www.apollographql.com/docs/react/pagination/core-api/).\n   */\n  ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {\n    var _this = this;\n    var combinedOptions = __assign(__assign({}, fetchMoreOptions.query ? fetchMoreOptions : __assign(__assign(__assign(__assign({}, this.options), {\n      query: this.options.query\n    }), fetchMoreOptions), {\n      variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables)\n    })), {\n      // The fetchMore request goes immediately to the network and does\n      // not automatically write its result to the cache (hence no-cache\n      // instead of network-only), because we allow the caller of\n      // fetchMore to provide an updateQuery callback that determines how\n      // the data gets written to the cache.\n      fetchPolicy: \"no-cache\"\n    });\n    combinedOptions.query = this.transformDocument(combinedOptions.query);\n    var qid = this.queryManager.generateQueryId();\n    // If a temporary query is passed to `fetchMore`, we don't want to store\n    // it as the last query result since it may be an optimized query for\n    // pagination. We will however run the transforms on the original document\n    // as well as the document passed in `fetchMoreOptions` to ensure the cache\n    // uses the most up-to-date document which may rely on runtime conditionals.\n    this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;\n    // Simulate a loading result for the original query with\n    // result.networkStatus === NetworkStatus.fetchMore.\n    var queryInfo = this.queryInfo;\n    var originalNetworkStatus = queryInfo.networkStatus;\n    queryInfo.networkStatus = NetworkStatus.fetchMore;\n    if (combinedOptions.notifyOnNetworkStatusChange) {\n      this.observe();\n    }\n    var updatedQuerySet = new Set();\n    var updateQuery = fetchMoreOptions === null || fetchMoreOptions === void 0 ? void 0 : fetchMoreOptions.updateQuery;\n    var isCached = this.options.fetchPolicy !== \"no-cache\";\n    if (!isCached) {\n      invariant(updateQuery, 22);\n    }\n    return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function (fetchMoreResult) {\n      _this.queryManager.removeQuery(qid);\n      if (queryInfo.networkStatus === NetworkStatus.fetchMore) {\n        queryInfo.networkStatus = originalNetworkStatus;\n      }\n      if (isCached) {\n        // Performing this cache update inside a cache.batch transaction ensures\n        // any affected cache.watch watchers are notified at most once about any\n        // updates. Most watchers will be using the QueryInfo class, which\n        // responds to notifications by calling reobserveCacheFirst to deliver\n        // fetchMore cache results back to this ObservableQuery.\n        _this.queryManager.cache.batch({\n          update: function (cache) {\n            var updateQuery = fetchMoreOptions.updateQuery;\n            if (updateQuery) {\n              cache.updateQuery({\n                query: _this.query,\n                variables: _this.variables,\n                returnPartialData: true,\n                optimistic: false\n              }, function (previous) {\n                return updateQuery(previous, {\n                  fetchMoreResult: fetchMoreResult.data,\n                  variables: combinedOptions.variables\n                });\n              });\n            } else {\n              // If we're using a field policy instead of updateQuery, the only\n              // thing we need to do is write the new data to the cache using\n              // combinedOptions.variables (instead of this.variables, which is\n              // what this.updateQuery uses, because it works by abusing the\n              // original field value, keyed by the original variables).\n              cache.writeQuery({\n                query: combinedOptions.query,\n                variables: combinedOptions.variables,\n                data: fetchMoreResult.data\n              });\n            }\n          },\n          onWatchUpdated: function (watch) {\n            // Record the DocumentNode associated with any watched query whose\n            // data were updated by the cache writes above.\n            updatedQuerySet.add(watch.query);\n          }\n        });\n      } else {\n        // There is a possibility `lastResult` may not be set when\n        // `fetchMore` is called which would cause this to crash. This should\n        // only happen if we haven't previously reported a result. We don't\n        // quite know what the right behavior should be here since this block\n        // of code runs after the fetch result has executed on the network.\n        // We plan to let it crash in the meantime.\n        //\n        // If we get bug reports due to the `data` property access on\n        // undefined, this should give us a real-world scenario that we can\n        // use to test against and determine the right behavior. If we do end\n        // up changing this behavior, this may require, for example, an\n        // adjustment to the types on `updateQuery` since that function\n        // expects that the first argument always contains previous result\n        // data, but not `undefined`.\n        var lastResult = _this.getLast(\"result\");\n        var data = updateQuery(lastResult.data, {\n          fetchMoreResult: fetchMoreResult.data,\n          variables: combinedOptions.variables\n        });\n        _this.reportResult(__assign(__assign({}, lastResult), {\n          networkStatus: originalNetworkStatus,\n          loading: isNetworkRequestInFlight(originalNetworkStatus),\n          data: data\n        }), _this.variables);\n      }\n      return _this.maskResult(fetchMoreResult);\n    }).finally(function () {\n      // In case the cache writes above did not generate a broadcast\n      // notification (which would have been intercepted by onWatchUpdated),\n      // likely because the written data were the same as what was already in\n      // the cache, we still want fetchMore to deliver its final loading:false\n      // result with the unchanged data.\n      if (isCached && !updatedQuerySet.has(_this.query)) {\n        reobserveCacheFirst(_this);\n      }\n    });\n  };\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  /**\n   * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\n   *\n   * This function returns _another_ function that you can call to terminate the subscription.\n   */\n  ObservableQuery.prototype.subscribeToMore = function (options) {\n    var _this = this;\n    var subscription = this.queryManager.startGraphQLSubscription({\n      query: options.document,\n      variables: options.variables,\n      context: options.context\n    }).subscribe({\n      next: function (subscriptionData) {\n        var updateQuery = options.updateQuery;\n        if (updateQuery) {\n          _this.updateQuery(function (previous, updateOptions) {\n            return updateQuery(previous, __assign({\n              subscriptionData: subscriptionData\n            }, updateOptions));\n          });\n        }\n      },\n      error: function (err) {\n        if (options.onError) {\n          options.onError(err);\n          return;\n        }\n        globalThis.__DEV__ !== false && invariant.error(23, err);\n      }\n    });\n    this.subscriptions.add(subscription);\n    return function () {\n      if (_this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  };\n  ObservableQuery.prototype.setOptions = function (newOptions) {\n    return this.reobserve(newOptions);\n  };\n  ObservableQuery.prototype.silentSetOptions = function (newOptions) {\n    var mergedOptions = compact(this.options, newOptions || {});\n    assign(this.options, mergedOptions);\n  };\n  /**\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. Most users should prefer `refetch` instead of\n   * `setVariables` in order to to be properly notified of results even when\n   * they come from the cache.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  ObservableQuery.prototype.setVariables = function (variables) {\n    if (equal(this.variables, variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return this.observers.size ? this.result() : Promise.resolve();\n    }\n    this.options.variables = variables;\n    // See comment above\n    if (!this.observers.size) {\n      return Promise.resolve();\n    }\n    return this.reobserve({\n      // Reset options.fetchPolicy to its original value.\n      fetchPolicy: this.options.initialFetchPolicy,\n      variables: variables\n    }, NetworkStatus.setVariables);\n  };\n  /**\n   * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\n   *\n   * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\n   */\n  ObservableQuery.prototype.updateQuery = function (mapFn) {\n    var queryManager = this.queryManager;\n    var _a = queryManager.cache.diff({\n        query: this.options.query,\n        variables: this.variables,\n        returnPartialData: true,\n        optimistic: false\n      }),\n      result = _a.result,\n      complete = _a.complete;\n    var newResult = mapFn(result, {\n      variables: this.variables,\n      complete: !!complete,\n      previousData: result\n    });\n    if (newResult) {\n      queryManager.cache.writeQuery({\n        query: this.options.query,\n        data: newResult,\n        variables: this.variables\n      });\n      queryManager.broadcastQueries();\n    }\n  };\n  /**\n   * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\n   */\n  ObservableQuery.prototype.startPolling = function (pollInterval) {\n    this.options.pollInterval = pollInterval;\n    this.updatePolling();\n  };\n  /**\n   * A function that instructs the query to stop polling after a previous call to `startPolling`.\n   */\n  ObservableQuery.prototype.stopPolling = function () {\n    this.options.pollInterval = 0;\n    this.updatePolling();\n  };\n  // Update options.fetchPolicy according to options.nextFetchPolicy.\n  ObservableQuery.prototype.applyNextFetchPolicy = function (reason,\n  // It's possible to use this method to apply options.nextFetchPolicy to\n  // options.fetchPolicy even if options !== this.options, though that happens\n  // most often when the options are temporary, used for only one request and\n  // then thrown away, so nextFetchPolicy may not end up mattering.\n  options) {\n    if (options.nextFetchPolicy) {\n      var _a = options.fetchPolicy,\n        fetchPolicy = _a === void 0 ? \"cache-first\" : _a,\n        _b = options.initialFetchPolicy,\n        initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;\n      if (fetchPolicy === \"standby\") {\n        // Do nothing, leaving options.fetchPolicy unchanged.\n      } else if (typeof options.nextFetchPolicy === \"function\") {\n        // When someone chooses \"cache-and-network\" or \"network-only\" as their\n        // initial FetchPolicy, they often do not want future cache updates to\n        // trigger unconditional network requests, which is what repeatedly\n        // applying the \"cache-and-network\" or \"network-only\" policies would\n        // seem to imply. Instead, when the cache reports an update after the\n        // initial network request, it may be desirable for subsequent network\n        // requests to be triggered only if the cache result is incomplete. To\n        // that end, the options.nextFetchPolicy option provides an easy way to\n        // update options.fetchPolicy after the initial network request, without\n        // having to call observableQuery.setOptions.\n        options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {\n          reason: reason,\n          options: options,\n          observable: this,\n          initialFetchPolicy: initialFetchPolicy\n        });\n      } else if (reason === \"variables-changed\") {\n        options.fetchPolicy = initialFetchPolicy;\n      } else {\n        options.fetchPolicy = options.nextFetchPolicy;\n      }\n    }\n    return options.fetchPolicy;\n  };\n  ObservableQuery.prototype.fetch = function (options, newNetworkStatus, query) {\n    // TODO Make sure we update the networkStatus (and infer fetchVariables)\n    // before actually committing to the fetch.\n    this.queryManager.setObservableQuery(this);\n    return this.queryManager[\"fetchConcastWithInfo\"](this.queryId, options, newNetworkStatus, query);\n  };\n  // Turns polling on or off based on this.options.pollInterval.\n  ObservableQuery.prototype.updatePolling = function () {\n    var _this = this;\n    // Avoid polling in SSR mode\n    if (this.queryManager.ssrMode) {\n      return;\n    }\n    var _a = this,\n      pollingInfo = _a.pollingInfo,\n      pollInterval = _a.options.pollInterval;\n    if (!pollInterval || !this.hasObservers()) {\n      if (pollingInfo) {\n        clearTimeout(pollingInfo.timeout);\n        delete this.pollingInfo;\n      }\n      return;\n    }\n    if (pollingInfo && pollingInfo.interval === pollInterval) {\n      return;\n    }\n    invariant(pollInterval, 24);\n    var info = pollingInfo || (this.pollingInfo = {});\n    info.interval = pollInterval;\n    var maybeFetch = function () {\n      var _a, _b;\n      if (_this.pollingInfo) {\n        if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus) && !((_b = (_a = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n          _this.reobserve({\n            // Most fetchPolicy options don't make sense to use in a polling context, as\n            // users wouldn't want to be polling the cache directly. However, network-only and\n            // no-cache are both useful for when the user wants to control whether or not the\n            // polled results are written to the cache.\n            fetchPolicy: _this.options.initialFetchPolicy === \"no-cache\" ? \"no-cache\" : \"network-only\"\n          }, NetworkStatus.poll).then(poll, poll);\n        } else {\n          poll();\n        }\n      }\n    };\n    var poll = function () {\n      var info = _this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n    poll();\n  };\n  ObservableQuery.prototype.updateLastResult = function (newResult, variables) {\n    if (variables === void 0) {\n      variables = this.variables;\n    }\n    var error = this.getLastError();\n    // Preserve this.last.error unless the variables have changed.\n    if (error && this.last && !equal(variables, this.last.variables)) {\n      error = void 0;\n    }\n    return this.last = __assign({\n      result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult),\n      variables: variables\n    }, error ? {\n      error: error\n    } : null);\n  };\n  ObservableQuery.prototype.reobserveAsConcast = function (newOptions, newNetworkStatus) {\n    var _this = this;\n    this.isTornDown = false;\n    var useDisposableConcast =\n    // Refetching uses a disposable Concast to allow refetches using different\n    // options/variables, without permanently altering the options of the\n    // original ObservableQuery.\n    newNetworkStatus === NetworkStatus.refetch ||\n    // The fetchMore method does not actually call the reobserve method, but,\n    // if it did, it would definitely use a disposable Concast.\n    newNetworkStatus === NetworkStatus.fetchMore ||\n    // Polling uses a disposable Concast so the polling options (which force\n    // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n    newNetworkStatus === NetworkStatus.poll;\n    // Save the old variables, since Object.assign may modify them below.\n    var oldVariables = this.options.variables;\n    var oldFetchPolicy = this.options.fetchPolicy;\n    var mergedOptions = compact(this.options, newOptions || {});\n    var options = useDisposableConcast ?\n    // Disposable Concast fetches receive a shallow copy of this.options\n    // (merged with newOptions), leaving this.options unmodified.\n    mergedOptions : assign(this.options, mergedOptions);\n    // Don't update options.query with the transformed query to avoid\n    // overwriting this.options.query when we aren't using a disposable concast.\n    // We want to ensure we can re-run the custom document transforms the next\n    // time a request is made against the original query.\n    var query = this.transformDocument(options.query);\n    this.lastQuery = query;\n    if (!useDisposableConcast) {\n      // We can skip calling updatePolling if we're not changing this.options.\n      this.updatePolling();\n      // Reset options.fetchPolicy to its original value when variables change,\n      // unless a new fetchPolicy was provided by newOptions.\n      if (newOptions && newOptions.variables && !equal(newOptions.variables, oldVariables) &&\n      // Don't mess with the fetchPolicy if it's currently \"standby\".\n      options.fetchPolicy !== \"standby\" && (\n      // If we're changing the fetchPolicy anyway, don't try to change it here\n      // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n      options.fetchPolicy === oldFetchPolicy ||\n      // A `nextFetchPolicy` function has even higher priority, though,\n      // so in that case `applyNextFetchPolicy` must be called.\n      typeof options.nextFetchPolicy === \"function\")) {\n        this.applyNextFetchPolicy(\"variables-changed\", options);\n        if (newNetworkStatus === void 0) {\n          newNetworkStatus = NetworkStatus.setVariables;\n        }\n      }\n    }\n    this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));\n    var finishWaitingForOwnResult = function () {\n      if (_this.concast === concast) {\n        _this.waitForOwnResult = false;\n      }\n    };\n    var variables = options.variables && __assign({}, options.variables);\n    var _a = this.fetch(options, newNetworkStatus, query),\n      concast = _a.concast,\n      fromLink = _a.fromLink;\n    var observer = {\n      next: function (result) {\n        if (equal(_this.variables, variables)) {\n          finishWaitingForOwnResult();\n          _this.reportResult(result, variables);\n        }\n      },\n      error: function (error) {\n        if (equal(_this.variables, variables)) {\n          // Coming from `getResultsFromLink`, `error` here should always be an `ApolloError`.\n          // However, calling `concast.cancel` can inject another type of error, so we have to\n          // wrap it again here.\n          if (!isApolloError(error)) {\n            error = new ApolloError({\n              networkError: error\n            });\n          }\n          finishWaitingForOwnResult();\n          _this.reportError(error, variables);\n        }\n      }\n    };\n    if (!useDisposableConcast && (fromLink || !this.concast)) {\n      // We use the {add,remove}Observer methods directly to avoid wrapping\n      // observer with an unnecessary SubscriptionObserver object.\n      if (this.concast && this.observer) {\n        this.concast.removeObserver(this.observer);\n      }\n      this.concast = concast;\n      this.observer = observer;\n    }\n    concast.addObserver(observer);\n    return concast;\n  };\n  ObservableQuery.prototype.reobserve = function (newOptions, newNetworkStatus) {\n    return preventUnhandledRejection(this.reobserveAsConcast(newOptions, newNetworkStatus).promise.then(this.maskResult));\n  };\n  ObservableQuery.prototype.resubscribeAfterError = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    // If `lastError` is set in the current when the subscription is re-created,\n    // the subscription will immediately receive the error, which will\n    // cause it to terminate again. To avoid this, we first clear\n    // the last error/result from the `observableQuery` before re-starting\n    // the subscription, and restore the last value afterwards so that the\n    // subscription has a chance to stay open.\n    var last = this.last;\n    this.resetLastResults();\n    var subscription = this.subscribe.apply(this, args);\n    this.last = last;\n    return subscription;\n  };\n  // (Re)deliver the current result to this.observers without applying fetch\n  // policies or making network requests.\n  ObservableQuery.prototype.observe = function () {\n    this.reportResult(\n    // Passing false is important so that this.getCurrentResult doesn't\n    // save the fetchMore result as this.lastResult, causing it to be\n    // ignored due to the this.isDifferentFromLastResult check in\n    // this.reportResult.\n    this.getCurrentFullResult(false), this.variables);\n  };\n  ObservableQuery.prototype.reportResult = function (result, variables) {\n    var lastError = this.getLastError();\n    var isDifferent = this.isDifferentFromLastResult(result, variables);\n    // Update the last result even when isDifferentFromLastResult returns false,\n    // because the query may be using the @nonreactive directive, and we want to\n    // save the the latest version of any nonreactive subtrees (in case\n    // getCurrentResult is called), even though we skip broadcasting changes.\n    if (lastError || !result.partial || this.options.returnPartialData) {\n      this.updateLastResult(result, variables);\n    }\n    if (lastError || isDifferent) {\n      iterateObserversSafely(this.observers, \"next\", this.maskResult(result));\n    }\n  };\n  ObservableQuery.prototype.reportError = function (error, variables) {\n    // Since we don't get the current result on errors, only the error, we\n    // must mirror the updates that occur in QueryStore.markQueryError here\n    var errorResult = __assign(__assign({}, this.getLastResult()), {\n      error: error,\n      errors: error.graphQLErrors,\n      networkStatus: NetworkStatus.error,\n      loading: false\n    });\n    this.updateLastResult(errorResult, variables);\n    iterateObserversSafely(this.observers, \"error\", this.last.error = error);\n  };\n  ObservableQuery.prototype.hasObservers = function () {\n    return this.observers.size > 0;\n  };\n  ObservableQuery.prototype.tearDownQuery = function () {\n    if (this.isTornDown) return;\n    if (this.concast && this.observer) {\n      this.concast.removeObserver(this.observer);\n      delete this.concast;\n      delete this.observer;\n    }\n    this.stopPolling();\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach(function (sub) {\n      return sub.unsubscribe();\n    });\n    this.subscriptions.clear();\n    this.queryManager.stopQuery(this.queryId);\n    this.observers.clear();\n    this.isTornDown = true;\n  };\n  ObservableQuery.prototype.transformDocument = function (document) {\n    return this.queryManager.transform(document);\n  };\n  ObservableQuery.prototype.maskResult = function (result) {\n    return result && \"data\" in result ? __assign(__assign({}, result), {\n      data: this.queryManager.maskOperation({\n        document: this.query,\n        data: result.data,\n        fetchPolicy: this.options.fetchPolicy,\n        id: this.queryId\n      })\n    }) : result;\n  };\n  return ObservableQuery;\n}(Observable);\nexport { ObservableQuery };\n// Necessary because the ObservableQuery constructor has a different\n// signature than the Observable constructor.\nfixObservableSubclass(ObservableQuery);\n// Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n// delivery of any new data from the cache, possibly falling back to the network\n// if any cache data are missing. This allows _complete_ cache results to be\n// delivered without also kicking off unnecessary network requests when\n// this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n// this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n// \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\nexport function reobserveCacheFirst(obsQuery) {\n  var _a = obsQuery.options,\n    fetchPolicy = _a.fetchPolicy,\n    nextFetchPolicy = _a.nextFetchPolicy;\n  if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n    return obsQuery.reobserve({\n      fetchPolicy: \"cache-first\",\n      // Use a temporary nextFetchPolicy function that replaces itself with the\n      // previous nextFetchPolicy value and returns the original fetchPolicy.\n      nextFetchPolicy: function (currentFetchPolicy, context) {\n        // Replace this nextFetchPolicy function in the options object with the\n        // original this.options.nextFetchPolicy value.\n        this.nextFetchPolicy = nextFetchPolicy;\n        // If the original nextFetchPolicy value was a function, give it a\n        // chance to decide what happens here.\n        if (typeof this.nextFetchPolicy === \"function\") {\n          return this.nextFetchPolicy(currentFetchPolicy, context);\n        }\n        // Otherwise go back to the original this.options.fetchPolicy.\n        return fetchPolicy;\n      }\n    });\n  }\n  return obsQuery.reobserve();\n}\nfunction defaultSubscriptionObserverErrorCallback(error) {\n  globalThis.__DEV__ !== false && invariant.error(25, error.message, error.stack);\n}\nexport function logMissingFieldErrors(missing) {\n  if (globalThis.__DEV__ !== false && missing) {\n    globalThis.__DEV__ !== false && invariant.debug(26, missing);\n  }\n}\nfunction skipCacheDataFor(fetchPolicy /* `undefined` would mean `\"cache-first\"` */) {\n  return fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\" || fetchPolicy === \"standby\";\n}\n", "import { __assign } from \"tslib\";\nimport { equal } from \"@wry/equality\";\nimport { DeepMerger } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/index.js\";\nimport { reobserveCacheFirst } from \"./ObservableQuery.js\";\nimport { isNonEmptyArray, graphQLResultHasError, canUseWeakMap } from \"../utilities/index.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nvar destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();\nfunction wrapDestructiveCacheMethod(cache, methodName) {\n  var original = cache[methodName];\n  if (typeof original === \"function\") {\n    // @ts-expect-error this is just too generic to be typed correctly\n    cache[methodName] = function () {\n      destructiveMethodCounts.set(cache,\n      // The %1e15 allows the count to wrap around to 0 safely every\n      // quadrillion evictions, so there's no risk of overflow. To be\n      // clear, this is more of a pedantic principle than something\n      // that matters in any conceivable practical scenario.\n      (destructiveMethodCounts.get(cache) + 1) % 1e15);\n      // @ts-expect-error this is just too generic to be typed correctly\n      return original.apply(this, arguments);\n    };\n  }\n}\nfunction cancelNotifyTimeout(info) {\n  if (info[\"notifyTimeout\"]) {\n    clearTimeout(info[\"notifyTimeout\"]);\n    info[\"notifyTimeout\"] = void 0;\n  }\n}\n// A QueryInfo object represents a single query managed by the\n// QueryManager, which tracks all QueryInfo objects by queryId in its\n// this.queries Map. QueryInfo objects store the latest results and errors\n// for the given query, and are responsible for reporting those results to\n// the corresponding ObservableQuery, via the QueryInfo.notify method.\n// Results are reported asynchronously whenever setDiff marks the\n// QueryInfo object as dirty, though a call to the QueryManager's\n// broadcastQueries method may trigger the notification before it happens\n// automatically. This class used to be a simple interface type without\n// any field privacy or meaningful methods, which is why it still has so\n// many public fields. The effort to lock down and simplify the QueryInfo\n// interface is ongoing, and further improvements are welcome.\nvar QueryInfo = /** @class */function () {\n  function QueryInfo(queryManager, queryId) {\n    if (queryId === void 0) {\n      queryId = queryManager.generateQueryId();\n    }\n    this.queryId = queryId;\n    this.listeners = new Set();\n    this.document = null;\n    this.lastRequestId = 1;\n    this.stopped = false;\n    this.dirty = false;\n    this.observableQuery = null;\n    var cache = this.cache = queryManager.cache;\n    // Track how often cache.evict is called, since we want eviction to\n    // override the feud-stopping logic in the markResult method, by\n    // causing shouldWrite to return true. Wrapping the cache.evict method\n    // is a bit of a hack, but it saves us from having to make eviction\n    // counting an official part of the ApolloCache API.\n    if (!destructiveMethodCounts.has(cache)) {\n      destructiveMethodCounts.set(cache, 0);\n      wrapDestructiveCacheMethod(cache, \"evict\");\n      wrapDestructiveCacheMethod(cache, \"modify\");\n      wrapDestructiveCacheMethod(cache, \"reset\");\n    }\n  }\n  QueryInfo.prototype.init = function (query) {\n    var networkStatus = query.networkStatus || NetworkStatus.loading;\n    if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal(this.variables, query.variables)) {\n      networkStatus = NetworkStatus.setVariables;\n    }\n    if (!equal(query.variables, this.variables)) {\n      this.lastDiff = void 0;\n    }\n    Object.assign(this, {\n      document: query.document,\n      variables: query.variables,\n      networkError: null,\n      graphQLErrors: this.graphQLErrors || [],\n      networkStatus: networkStatus\n    });\n    if (query.observableQuery) {\n      this.setObservableQuery(query.observableQuery);\n    }\n    if (query.lastRequestId) {\n      this.lastRequestId = query.lastRequestId;\n    }\n    return this;\n  };\n  QueryInfo.prototype.reset = function () {\n    cancelNotifyTimeout(this);\n    this.dirty = false;\n  };\n  QueryInfo.prototype.resetDiff = function () {\n    this.lastDiff = void 0;\n  };\n  QueryInfo.prototype.getDiff = function () {\n    var options = this.getDiffOptions();\n    if (this.lastDiff && equal(options, this.lastDiff.options)) {\n      return this.lastDiff.diff;\n    }\n    this.updateWatch(this.variables);\n    var oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return {\n        complete: false\n      };\n    }\n    var diff = this.cache.diff(options);\n    this.updateLastDiff(diff, options);\n    return diff;\n  };\n  QueryInfo.prototype.updateLastDiff = function (diff, options) {\n    this.lastDiff = diff ? {\n      diff: diff,\n      options: options || this.getDiffOptions()\n    } : void 0;\n  };\n  QueryInfo.prototype.getDiffOptions = function (variables) {\n    var _a;\n    if (variables === void 0) {\n      variables = this.variables;\n    }\n    return {\n      query: this.document,\n      variables: variables,\n      returnPartialData: true,\n      optimistic: true,\n      canonizeResults: (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.options.canonizeResults\n    };\n  };\n  QueryInfo.prototype.setDiff = function (diff) {\n    var _this = this;\n    var _a;\n    var oldDiff = this.lastDiff && this.lastDiff.diff;\n    // If we are trying to deliver an incomplete cache result, we avoid\n    // reporting it if the query has errored, otherwise we let the broadcast try\n    // and repair the partial result by refetching the query. This check avoids\n    // a situation where a query that errors and another succeeds with\n    // overlapping data does not report the partial data result to the errored\n    // query.\n    //\n    // See https://github.com/apollographql/apollo-client/issues/11400 for more\n    // information on this issue.\n    if (diff && !diff.complete && ((_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.getLastError())) {\n      return;\n    }\n    this.updateLastDiff(diff);\n    if (!this.dirty && !equal(oldDiff && oldDiff.result, diff && diff.result)) {\n      this.dirty = true;\n      if (!this.notifyTimeout) {\n        this.notifyTimeout = setTimeout(function () {\n          return _this.notify();\n        }, 0);\n      }\n    }\n  };\n  QueryInfo.prototype.setObservableQuery = function (oq) {\n    var _this = this;\n    if (oq === this.observableQuery) return;\n    if (this.oqListener) {\n      this.listeners.delete(this.oqListener);\n    }\n    this.observableQuery = oq;\n    if (oq) {\n      oq[\"queryInfo\"] = this;\n      this.listeners.add(this.oqListener = function () {\n        var diff = _this.getDiff();\n        if (diff.fromOptimisticTransaction) {\n          // If this diff came from an optimistic transaction, deliver the\n          // current cache data to the ObservableQuery, but don't perform a\n          // reobservation, since oq.reobserveCacheFirst might make a network\n          // request, and we never want to trigger network requests in the\n          // middle of optimistic updates.\n          oq[\"observe\"]();\n        } else {\n          // Otherwise, make the ObservableQuery \"reobserve\" the latest data\n          // using a temporary fetch policy of \"cache-first\", so complete cache\n          // results have a chance to be delivered without triggering additional\n          // network requests, even when options.fetchPolicy is \"network-only\"\n          // or \"cache-and-network\". All other fetch policies are preserved by\n          // this method, and are handled by calling oq.reobserve(). If this\n          // reobservation is spurious, isDifferentFromLastResult still has a\n          // chance to catch it before delivery to ObservableQuery subscribers.\n          reobserveCacheFirst(oq);\n        }\n      });\n    } else {\n      delete this.oqListener;\n    }\n  };\n  QueryInfo.prototype.notify = function () {\n    var _this = this;\n    cancelNotifyTimeout(this);\n    if (this.shouldNotify()) {\n      this.listeners.forEach(function (listener) {\n        return listener(_this);\n      });\n    }\n    this.dirty = false;\n  };\n  QueryInfo.prototype.shouldNotify = function () {\n    if (!this.dirty || !this.listeners.size) {\n      return false;\n    }\n    if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {\n      var fetchPolicy = this.observableQuery.options.fetchPolicy;\n      if (fetchPolicy !== \"cache-only\" && fetchPolicy !== \"cache-and-network\") {\n        return false;\n      }\n    }\n    return true;\n  };\n  QueryInfo.prototype.stop = function () {\n    if (!this.stopped) {\n      this.stopped = true;\n      // Cancel the pending notify timeout\n      this.reset();\n      this.cancel();\n      // Revert back to the no-op version of cancel inherited from\n      // QueryInfo.prototype.\n      this.cancel = QueryInfo.prototype.cancel;\n      var oq = this.observableQuery;\n      if (oq) oq.stopPolling();\n    }\n  };\n  // This method is a no-op by default, until/unless overridden by the\n  // updateWatch method.\n  QueryInfo.prototype.cancel = function () {};\n  QueryInfo.prototype.updateWatch = function (variables) {\n    var _this = this;\n    if (variables === void 0) {\n      variables = this.variables;\n    }\n    var oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return;\n    }\n    var watchOptions = __assign(__assign({}, this.getDiffOptions(variables)), {\n      watcher: this,\n      callback: function (diff) {\n        return _this.setDiff(diff);\n      }\n    });\n    if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {\n      this.cancel();\n      this.cancel = this.cache.watch(this.lastWatch = watchOptions);\n    }\n  };\n  QueryInfo.prototype.resetLastWrite = function () {\n    this.lastWrite = void 0;\n  };\n  QueryInfo.prototype.shouldWrite = function (result, variables) {\n    var lastWrite = this.lastWrite;\n    return !(lastWrite &&\n    // If cache.evict has been called since the last time we wrote this\n    // data into the cache, there's a chance writing this result into\n    // the cache will repair what was evicted.\n    lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal(variables, lastWrite.variables) && equal(result.data, lastWrite.result.data));\n  };\n  QueryInfo.prototype.markResult = function (result, document, options, cacheWriteBehavior) {\n    var _this = this;\n    var merger = new DeepMerger();\n    var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];\n    // Cancel the pending notify timeout (if it exists) to prevent extraneous network\n    // requests. To allow future notify timeouts, diff and dirty are reset as well.\n    this.reset();\n    if (\"incremental\" in result && isNonEmptyArray(result.incremental)) {\n      var mergedData = mergeIncrementalData(this.getDiff().result, result);\n      result.data = mergedData;\n      // Detect the first chunk of a deferred query and merge it with existing\n      // cache data. This ensures a `cache-first` fetch policy that returns\n      // partial cache data or a `cache-and-network` fetch policy that already\n      // has full data in the cache does not complain when trying to merge the\n      // initial deferred server data with existing cache data.\n    } else if (\"hasNext\" in result && result.hasNext) {\n      var diff = this.getDiff();\n      result.data = merger.merge(diff.result, result.data);\n    }\n    this.graphQLErrors = graphQLErrors;\n    if (options.fetchPolicy === \"no-cache\") {\n      this.updateLastDiff({\n        result: result.data,\n        complete: true\n      }, this.getDiffOptions(options.variables));\n    } else if (cacheWriteBehavior !== 0 /* CacheWriteBehavior.FORBID */) {\n      if (shouldWriteResult(result, options.errorPolicy)) {\n        // Using a transaction here so we have a chance to read the result\n        // back from the cache before the watch callback fires as a result\n        // of writeQuery, so we can store the new diff quietly and ignore\n        // it when we receive it redundantly from the watch callback.\n        this.cache.performTransaction(function (cache) {\n          if (_this.shouldWrite(result, options.variables)) {\n            cache.writeQuery({\n              query: document,\n              data: result.data,\n              variables: options.variables,\n              overwrite: cacheWriteBehavior === 1 /* CacheWriteBehavior.OVERWRITE */\n            });\n            _this.lastWrite = {\n              result: result,\n              variables: options.variables,\n              dmCount: destructiveMethodCounts.get(_this.cache)\n            };\n          } else {\n            // If result is the same as the last result we received from\n            // the network (and the variables match too), avoid writing\n            // result into the cache again. The wisdom of skipping this\n            // cache write is far from obvious, since any cache write\n            // could be the one that puts the cache back into a desired\n            // state, fixing corruption or missing data. However, if we\n            // always write every network result into the cache, we enable\n            // feuds between queries competing to update the same data in\n            // incompatible ways, which can lead to an endless cycle of\n            // cache broadcasts and useless network requests. As with any\n            // feud, eventually one side must step back from the brink,\n            // letting the other side(s) have the last word(s). There may\n            // be other points where we could break this cycle, such as\n            // silencing the broadcast for cache.writeQuery (not a good\n            // idea, since it just delays the feud a bit) or somehow\n            // avoiding the network request that just happened (also bad,\n            // because the server could return useful new data). All\n            // options considered, skipping this cache write seems to be\n            // the least damaging place to break the cycle, because it\n            // reflects the intuition that we recently wrote this exact\n            // result into the cache, so the cache *should* already/still\n            // contain this data. If some other query has clobbered that\n            // data in the meantime, that's too bad, but there will be no\n            // winners if every query blindly reverts to its own version\n            // of the data. This approach also gives the network a chance\n            // to return new data, which will be written into the cache as\n            // usual, notifying only those queries that are directly\n            // affected by the cache updates, as usual. In the future, an\n            // even more sophisticated cache could perhaps prevent or\n            // mitigate the clobbering somehow, but that would make this\n            // particular cache write even less important, and thus\n            // skipping it would be even safer than it is today.\n            if (_this.lastDiff && _this.lastDiff.diff.complete) {\n              // Reuse data from the last good (complete) diff that we\n              // received, when possible.\n              result.data = _this.lastDiff.diff.result;\n              return;\n            }\n            // If the previous this.diff was incomplete, fall through to\n            // re-reading the latest data with cache.diff, below.\n          }\n          var diffOptions = _this.getDiffOptions(options.variables);\n          var diff = cache.diff(diffOptions);\n          // In case the QueryManager stops this QueryInfo before its\n          // results are delivered, it's important to avoid restarting the\n          // cache watch when markResult is called. We also avoid updating\n          // the watch if we are writing a result that doesn't match the current\n          // variables to avoid race conditions from broadcasting the wrong\n          // result.\n          if (!_this.stopped && equal(_this.variables, options.variables)) {\n            // Any time we're about to update this.diff, we need to make\n            // sure we've started watching the cache.\n            _this.updateWatch(options.variables);\n          }\n          // If we're allowed to write to the cache, and we can read a\n          // complete result from the cache, update result.data to be the\n          // result from the cache, rather than the raw network result.\n          // Set without setDiff to avoid triggering a notify call, since\n          // we have other ways of notifying for this result.\n          _this.updateLastDiff(diff, diffOptions);\n          if (diff.complete) {\n            result.data = diff.result;\n          }\n        });\n      } else {\n        this.lastWrite = void 0;\n      }\n    }\n  };\n  QueryInfo.prototype.markReady = function () {\n    this.networkError = null;\n    return this.networkStatus = NetworkStatus.ready;\n  };\n  QueryInfo.prototype.markError = function (error) {\n    this.networkStatus = NetworkStatus.error;\n    this.lastWrite = void 0;\n    this.reset();\n    if (error.graphQLErrors) {\n      this.graphQLErrors = error.graphQLErrors;\n    }\n    if (error.networkError) {\n      this.networkError = error.networkError;\n    }\n    return error;\n  };\n  return QueryInfo;\n}();\nexport { QueryInfo };\nexport function shouldWriteResult(result, errorPolicy) {\n  if (errorPolicy === void 0) {\n    errorPolicy = \"none\";\n  }\n  var ignoreErrors = errorPolicy === \"ignore\" || errorPolicy === \"all\";\n  var writeWithErrors = !graphQLResultHasError(result);\n  if (!writeWithErrors && ignoreErrors && result.data) {\n    writeWithErrors = true;\n  }\n  return writeWithErrors;\n}\n", "import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { execute } from \"../link/core/index.js\";\nimport { addNonReactiveToNamedFragments, hasDirectives, isExecutionPatchIncrementalResult, isExecutionPatchResult, isFullyUnmaskedOperation, removeDirectivesFromDocument } from \"../utilities/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, getGraphQLErrorsFromResult, Observable, asyncMap, isNonEmptyArray, Concast, makeUniqueId, isDocumentNode, isNonNullObject, DocumentTransform } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors } from \"../errors/index.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { QueryInfo, shouldWriteResult } from \"./QueryInfo.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar IGNORE = Object.create(null);\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\nimport { maskFragment, maskOperation } from \"../masking/index.js\";\nvar QueryManager = /** @class */function () {\n  function QueryManager(options) {\n    var _this = this;\n    this.clientAwareness = {};\n    // All the queries that the QueryManager is currently managing (not\n    // including mutations and subscriptions).\n    this.queries = new Map();\n    // Maps from queryId strings to Promise rejection functions for\n    // currently active queries and fetches.\n    // Use protected instead of private field so\n    // @apollo/experimental-nextjs-app-support can access type info.\n    this.fetchCancelFns = new Map();\n    this.transformCache = new AutoCleanedWeakCache(cacheSizes[\"queryManager.getDocumentInfo\"] || 2000 /* defaultCacheSizes[\"queryManager.getDocumentInfo\"] */);\n    this.queryIdCounter = 1;\n    this.requestIdCounter = 1;\n    this.mutationIdCounter = 1;\n    // Use protected instead of private field so\n    // @apollo/experimental-nextjs-app-support can access type info.\n    this.inFlightLinkObservables = new Trie(false);\n    this.noCacheWarningsByQueryId = new Set();\n    var defaultDocumentTransform = new DocumentTransform(function (document) {\n      return _this.cache.transformDocument(document);\n    },\n    // Allow the apollo cache to manage its own transform caches\n    {\n      cache: false\n    });\n    this.cache = options.cache;\n    this.link = options.link;\n    this.defaultOptions = options.defaultOptions;\n    this.queryDeduplication = options.queryDeduplication;\n    this.clientAwareness = options.clientAwareness;\n    this.localState = options.localState;\n    this.ssrMode = options.ssrMode;\n    this.assumeImmutableResults = options.assumeImmutableResults;\n    this.dataMasking = options.dataMasking;\n    var documentTransform = options.documentTransform;\n    this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform)\n    // The custom document transform may add new fragment spreads or new\n    // field selections, so we want to give the cache a chance to run\n    // again. For example, the InMemoryCache adds __typename to field\n    // selections and fragments from the fragment registry.\n    .concat(defaultDocumentTransform) : defaultDocumentTransform;\n    this.defaultContext = options.defaultContext || Object.create(null);\n    if (this.onBroadcast = options.onBroadcast) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  QueryManager.prototype.stop = function () {\n    var _this = this;\n    this.queries.forEach(function (_info, queryId) {\n      _this.stopQueryNoBroadcast(queryId);\n    });\n    this.cancelPendingFetches(newInvariantError(27));\n  };\n  QueryManager.prototype.cancelPendingFetches = function (error) {\n    this.fetchCancelFns.forEach(function (cancel) {\n      return cancel(error);\n    });\n    this.fetchCancelFns.clear();\n  };\n  QueryManager.prototype.mutate = function (_a) {\n    return __awaiter(this, arguments, void 0, function (_b) {\n      var mutationId, hasClientExports, mutationStoreValue, isOptimistic, self;\n      var _c, _d;\n      var mutation = _b.mutation,\n        variables = _b.variables,\n        optimisticResponse = _b.optimisticResponse,\n        updateQueries = _b.updateQueries,\n        _e = _b.refetchQueries,\n        refetchQueries = _e === void 0 ? [] : _e,\n        _f = _b.awaitRefetchQueries,\n        awaitRefetchQueries = _f === void 0 ? false : _f,\n        updateWithProxyFn = _b.update,\n        onQueryUpdated = _b.onQueryUpdated,\n        _g = _b.fetchPolicy,\n        fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || \"network-only\" : _g,\n        _h = _b.errorPolicy,\n        errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || \"none\" : _h,\n        keepRootFields = _b.keepRootFields,\n        context = _b.context;\n      return __generator(this, function (_j) {\n        switch (_j.label) {\n          case 0:\n            invariant(mutation, 28);\n            invariant(fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\", 29);\n            mutationId = this.generateMutationId();\n            mutation = this.cache.transformForLink(this.transform(mutation));\n            hasClientExports = this.getDocumentInfo(mutation).hasClientExports;\n            variables = this.getVariables(mutation, variables);\n            if (!hasClientExports) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.localState.addExportedVariables(mutation, variables, context)];\n          case 1:\n            variables = _j.sent();\n            _j.label = 2;\n          case 2:\n            mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {\n              mutation: mutation,\n              variables: variables,\n              loading: true,\n              error: null\n            });\n            isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {\n              mutationId: mutationId,\n              document: mutation,\n              variables: variables,\n              fetchPolicy: fetchPolicy,\n              errorPolicy: errorPolicy,\n              context: context,\n              updateQueries: updateQueries,\n              update: updateWithProxyFn,\n              keepRootFields: keepRootFields\n            });\n            this.broadcastQueries();\n            self = this;\n            return [2 /*return*/, new Promise(function (resolve, reject) {\n              return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), {\n                optimisticResponse: isOptimistic ? optimisticResponse : void 0\n              }), variables, {}, false), function (result) {\n                if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n                  throw new ApolloError({\n                    graphQLErrors: getGraphQLErrorsFromResult(result)\n                  });\n                }\n                if (mutationStoreValue) {\n                  mutationStoreValue.loading = false;\n                  mutationStoreValue.error = null;\n                }\n                var storeResult = __assign({}, result);\n                if (typeof refetchQueries === \"function\") {\n                  refetchQueries = refetchQueries(storeResult);\n                }\n                if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n                  delete storeResult.errors;\n                }\n                return self.markMutationResult({\n                  mutationId: mutationId,\n                  result: storeResult,\n                  document: mutation,\n                  variables: variables,\n                  fetchPolicy: fetchPolicy,\n                  errorPolicy: errorPolicy,\n                  context: context,\n                  update: updateWithProxyFn,\n                  updateQueries: updateQueries,\n                  awaitRefetchQueries: awaitRefetchQueries,\n                  refetchQueries: refetchQueries,\n                  removeOptimistic: isOptimistic ? mutationId : void 0,\n                  onQueryUpdated: onQueryUpdated,\n                  keepRootFields: keepRootFields\n                });\n              }).subscribe({\n                next: function (storeResult) {\n                  self.broadcastQueries();\n                  // Since mutations might receive multiple payloads from the\n                  // ApolloLink chain (e.g. when used with @defer),\n                  // we resolve with a SingleExecutionResult or after the final\n                  // ExecutionPatchResult has arrived and we have assembled the\n                  // multipart response into a single result.\n                  if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n                    resolve(__assign(__assign({}, storeResult), {\n                      data: self.maskOperation({\n                        document: mutation,\n                        data: storeResult.data,\n                        fetchPolicy: fetchPolicy,\n                        id: mutationId\n                      })\n                    }));\n                  }\n                },\n                error: function (err) {\n                  if (mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = err;\n                  }\n                  if (isOptimistic) {\n                    self.cache.removeOptimistic(mutationId);\n                  }\n                  self.broadcastQueries();\n                  reject(err instanceof ApolloError ? err : new ApolloError({\n                    networkError: err\n                  }));\n                }\n              });\n            })];\n        }\n      });\n    });\n  };\n  QueryManager.prototype.markMutationResult = function (mutation, cache) {\n    var _this = this;\n    if (cache === void 0) {\n      cache = this.cache;\n    }\n    var result = mutation.result;\n    var cacheWrites = [];\n    var skipCache = mutation.fetchPolicy === \"no-cache\";\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: \"ROOT_MUTATION\",\n          query: mutation.document,\n          variables: mutation.variables\n        });\n      }\n      if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {\n        var diff = cache.diff({\n          id: \"ROOT_MUTATION\",\n          // The cache complains if passed a mutation where it expects a\n          // query, so we transform mutations and subscriptions to queries\n          // (only once, thanks to this.transformCache).\n          query: this.getDocumentInfo(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true\n        });\n        var mergedData = void 0;\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n        if (typeof mergedData !== \"undefined\") {\n          // cast the ExecutionPatchResult to FetchResult here since\n          // ExecutionPatchResult never has `data` when returned from the server\n          result.data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: \"ROOT_MUTATION\",\n            query: mutation.document,\n            variables: mutation.variables\n          });\n        }\n      }\n      var updateQueries_1 = mutation.updateQueries;\n      if (updateQueries_1) {\n        this.queries.forEach(function (_a, queryId) {\n          var observableQuery = _a.observableQuery;\n          var queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n            return;\n          }\n          var updater = updateQueries_1[queryName];\n          var _b = _this.queries.get(queryId),\n            document = _b.document,\n            variables = _b.variables;\n          // Read the current query result from the store.\n          var _c = cache.diff({\n              query: document,\n              variables: variables,\n              returnPartialData: true,\n              optimistic: false\n            }),\n            currentQueryResult = _c.result,\n            complete = _c.complete;\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            var nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables\n            });\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: \"ROOT_QUERY\",\n                query: document,\n                variables: variables\n              });\n            }\n          }\n        });\n      }\n    }\n    if (cacheWrites.length > 0 || (mutation.refetchQueries || \"\").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {\n      var results_1 = [];\n      this.refetchQueries({\n        updateCache: function (cache) {\n          if (!skipCache) {\n            cacheWrites.forEach(function (write) {\n              return cache.write(write);\n            });\n          }\n          // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n          var update = mutation.update;\n          // Determine whether result is a SingleExecutionResult,\n          // or the final ExecutionPatchResult.\n          var isFinalResult = !isExecutionPatchResult(result) || isExecutionPatchIncrementalResult(result) && !result.hasNext;\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              var diff = cache.diff({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: _this.getDocumentInfo(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true\n              });\n              if (diff.complete) {\n                result = __assign(__assign({}, result), {\n                  data: diff.result\n                });\n                if (\"incremental\" in result) {\n                  delete result.incremental;\n                }\n                if (\"hasNext\" in result) {\n                  delete result.hasNext;\n                }\n              }\n            }\n            // If we've received the whole response,\n            // either a SingleExecutionResult or the final ExecutionPatchResult,\n            // call the update function.\n            if (isFinalResult) {\n              update(cache, result, {\n                context: mutation.context,\n                variables: mutation.variables\n              });\n            }\n          }\n          // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: \"ROOT_MUTATION\",\n              fields: function (value, _a) {\n                var fieldName = _a.fieldName,\n                  DELETE = _a.DELETE;\n                return fieldName === \"__typename\" ? value : DELETE;\n              }\n            });\n          }\n        },\n        include: mutation.refetchQueries,\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null\n      }).forEach(function (result) {\n        return results_1.push(result);\n      });\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results_1).then(function () {\n          return result;\n        });\n      }\n    }\n    return Promise.resolve(result);\n  };\n  QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n    var _this = this;\n    var data = typeof optimisticResponse === \"function\" ? optimisticResponse(mutation.variables, {\n      IGNORE: IGNORE\n    }) : optimisticResponse;\n    if (data === IGNORE) {\n      return false;\n    }\n    this.cache.recordOptimisticTransaction(function (cache) {\n      try {\n        _this.markMutationResult(__assign(__assign({}, mutation), {\n          result: {\n            data: data\n          }\n        }), cache);\n      } catch (error) {\n        globalThis.__DEV__ !== false && invariant.error(error);\n      }\n    }, mutation.mutationId);\n    return true;\n  };\n  QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n    return this.fetchConcastWithInfo(queryId, options, networkStatus).concast.promise;\n  };\n  QueryManager.prototype.getQueryStore = function () {\n    var store = Object.create(null);\n    this.queries.forEach(function (info, queryId) {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors\n      };\n    });\n    return store;\n  };\n  QueryManager.prototype.resetErrors = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  };\n  QueryManager.prototype.transform = function (document) {\n    return this.documentTransform.transformDocument(document);\n  };\n  QueryManager.prototype.getDocumentInfo = function (document) {\n    var transformCache = this.transformCache;\n    if (!transformCache.has(document)) {\n      var cacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasClientExports(document),\n        hasForcedResolvers: this.localState.shouldForceResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        nonReactiveQuery: addNonReactiveToNamedFragments(document),\n        clientQuery: this.localState.clientQuery(document),\n        serverQuery: removeDirectivesFromDocument([{\n          name: \"client\",\n          remove: true\n        }, {\n          name: \"connection\"\n        }, {\n          name: \"nonreactive\"\n        }, {\n          name: \"unmask\"\n        }], document),\n        defaultVars: getDefaultValues(getOperationDefinition(document)),\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: __assign(__assign({}, document), {\n          definitions: document.definitions.map(function (def) {\n            if (def.kind === \"OperationDefinition\" && def.operation !== \"query\") {\n              return __assign(__assign({}, def), {\n                operation: \"query\"\n              });\n            }\n            return def;\n          })\n        })\n      };\n      transformCache.set(document, cacheEntry);\n    }\n    return transformCache.get(document);\n  };\n  QueryManager.prototype.getVariables = function (document, variables) {\n    return __assign(__assign({}, this.getDocumentInfo(document).defaultVars), variables);\n  };\n  QueryManager.prototype.watchQuery = function (options) {\n    var query = this.transform(options.query);\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = __assign(__assign({}, options), {\n      variables: this.getVariables(query, options.variables)\n    });\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = false;\n    }\n    var queryInfo = new QueryInfo(this);\n    var observable = new ObservableQuery({\n      queryManager: this,\n      queryInfo: queryInfo,\n      options: options\n    });\n    observable[\"lastQuery\"] = query;\n    this.queries.set(observable.queryId, queryInfo);\n    // We give queryInfo the transformed query to ensure the first cache diff\n    // uses the transformed query instead of the raw query\n    queryInfo.init({\n      document: query,\n      observableQuery: observable,\n      variables: observable.variables\n    });\n    return observable;\n  };\n  QueryManager.prototype.query = function (options, queryId) {\n    var _this = this;\n    if (queryId === void 0) {\n      queryId = this.generateQueryId();\n    }\n    invariant(options.query, 30);\n    invariant(options.query.kind === \"Document\", 31);\n    invariant(!options.returnPartialData, 32);\n    invariant(!options.pollInterval, 33);\n    var query = this.transform(options.query);\n    return this.fetchQuery(queryId, __assign(__assign({}, options), {\n      query: query\n    })).then(function (result) {\n      return result && __assign(__assign({}, result), {\n        data: _this.maskOperation({\n          document: query,\n          data: result.data,\n          fetchPolicy: options.fetchPolicy,\n          id: queryId\n        })\n      });\n    }).finally(function () {\n      return _this.stopQuery(queryId);\n    });\n  };\n  QueryManager.prototype.generateQueryId = function () {\n    return String(this.queryIdCounter++);\n  };\n  QueryManager.prototype.generateRequestId = function () {\n    return this.requestIdCounter++;\n  };\n  QueryManager.prototype.generateMutationId = function () {\n    return String(this.mutationIdCounter++);\n  };\n  QueryManager.prototype.stopQueryInStore = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n  QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  };\n  QueryManager.prototype.clearStore = function (options) {\n    if (options === void 0) {\n      options = {\n        discardWatches: true\n      };\n    }\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(newInvariantError(34));\n    this.queries.forEach(function (queryInfo) {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n    // begin removing data from the store\n    return this.cache.reset(options);\n  };\n  QueryManager.prototype.getObservableQueries = function (include) {\n    var _this = this;\n    if (include === void 0) {\n      include = \"active\";\n    }\n    var queries = new Map();\n    var queryNames = new Map();\n    var queryNamesAndQueryStrings = new Map();\n    var legacyQueryOptions = new Set();\n    if (Array.isArray(include)) {\n      include.forEach(function (desc) {\n        if (typeof desc === \"string\") {\n          queryNames.set(desc, desc);\n          queryNamesAndQueryStrings.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          var queryString = print(_this.transform(desc));\n          queryNames.set(queryString, getOperationName(desc));\n          queryNamesAndQueryStrings.set(queryString, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n    this.queries.forEach(function (_a, queryId) {\n      var oq = _a.observableQuery,\n        document = _a.document;\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n        var queryName = oq.queryName,\n          fetchPolicy = oq.options.fetchPolicy;\n        if (fetchPolicy === \"standby\" || include === \"active\" && !oq.hasObservers()) {\n          return;\n        }\n        if (include === \"active\" || queryName && queryNamesAndQueryStrings.has(queryName) || document && queryNamesAndQueryStrings.has(print(document))) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndQueryStrings.set(queryName, true);\n          if (document) queryNamesAndQueryStrings.set(print(document), true);\n        }\n      }\n    });\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach(function (options) {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        var queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        var queryInfo = _this.getQuery(queryId).init({\n          document: options.query,\n          variables: options.variables\n        });\n        var oq = new ObservableQuery({\n          queryManager: _this,\n          queryInfo: queryInfo,\n          options: __assign(__assign({}, options), {\n            fetchPolicy: \"network-only\"\n          })\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n    if (globalThis.__DEV__ !== false && queryNamesAndQueryStrings.size) {\n      queryNamesAndQueryStrings.forEach(function (included, nameOrQueryString) {\n        if (!included) {\n          var queryName = queryNames.get(nameOrQueryString);\n          if (queryName) {\n            globalThis.__DEV__ !== false && invariant.warn(35, queryName);\n          } else {\n            globalThis.__DEV__ !== false && invariant.warn(36);\n          }\n        }\n      });\n    }\n    return queries;\n  };\n  QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n    var _this = this;\n    if (includeStandby === void 0) {\n      includeStandby = false;\n    }\n    var observableQueryPromises = [];\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function (observableQuery, queryId) {\n      var fetchPolicy = observableQuery.options.fetchPolicy;\n      observableQuery.resetLastResults();\n      if (includeStandby || fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\") {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n      _this.getQuery(queryId).setDiff(null);\n    });\n    this.broadcastQueries();\n    return Promise.all(observableQueryPromises);\n  };\n  QueryManager.prototype.setObservableQuery = function (observableQuery) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  };\n  QueryManager.prototype.startGraphQLSubscription = function (options) {\n    var _this = this;\n    var query = options.query,\n      variables = options.variables;\n    var fetchPolicy = options.fetchPolicy,\n      _a = options.errorPolicy,\n      errorPolicy = _a === void 0 ? \"none\" : _a,\n      _b = options.context,\n      context = _b === void 0 ? {} : _b,\n      _c = options.extensions,\n      extensions = _c === void 0 ? {} : _c;\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n    var makeObservable = function (variables) {\n      return _this.getObservableFromLink(query, context, variables, extensions).map(function (result) {\n        if (fetchPolicy !== \"no-cache\") {\n          // the subscription interface should handle not sending us results we no longer subscribe to.\n          // XXX I don't think we ever send in an object with errors, but we might in the future...\n          if (shouldWriteResult(result, errorPolicy)) {\n            _this.cache.write({\n              query: query,\n              result: result.data,\n              dataId: \"ROOT_SUBSCRIPTION\",\n              variables: variables\n            });\n          }\n          _this.broadcastQueries();\n        }\n        var hasErrors = graphQLResultHasError(result);\n        var hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n        if (hasErrors || hasProtocolErrors) {\n          var errors = {};\n          if (hasErrors) {\n            errors.graphQLErrors = result.errors;\n          }\n          if (hasProtocolErrors) {\n            errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n          }\n          // `errorPolicy` is a mechanism for handling GraphQL errors, according\n          // to our documentation, so we throw protocol errors regardless of the\n          // set error policy.\n          if (errorPolicy === \"none\" || hasProtocolErrors) {\n            throw new ApolloError(errors);\n          }\n        }\n        if (errorPolicy === \"ignore\") {\n          delete result.errors;\n        }\n        return result;\n      });\n    };\n    if (this.getDocumentInfo(query).hasClientExports) {\n      var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);\n      return new Observable(function (observer) {\n        var sub = null;\n        observablePromise_1.then(function (observable) {\n          return sub = observable.subscribe(observer);\n        }, observer.error);\n        return function () {\n          return sub && sub.unsubscribe();\n        };\n      });\n    }\n    return makeObservable(variables);\n  };\n  QueryManager.prototype.stopQuery = function (queryId) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n  QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  };\n  QueryManager.prototype.removeQuery = function (queryId) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      this.getQuery(queryId).stop();\n      this.queries.delete(queryId);\n    }\n  };\n  QueryManager.prototype.broadcastQueries = function () {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(function (info) {\n      return info.notify();\n    });\n  };\n  QueryManager.prototype.getLocalState = function () {\n    return this.localState;\n  };\n  QueryManager.prototype.getObservableFromLink = function (query, context, variables, extensions,\n  // Prefer context.queryDeduplication if specified.\n  deduplication) {\n    var _this = this;\n    var _a;\n    if (deduplication === void 0) {\n      deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;\n    }\n    var observable;\n    var _b = this.getDocumentInfo(query),\n      serverQuery = _b.serverQuery,\n      clientQuery = _b.clientQuery;\n    if (serverQuery) {\n      var _c = this,\n        inFlightLinkObservables_1 = _c.inFlightLinkObservables,\n        link = _c.link;\n      var operation = {\n        query: serverQuery,\n        variables: variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext(__assign(__assign({}, context), {\n          forceFetch: !deduplication\n        })),\n        extensions: extensions\n      };\n      context = operation.context;\n      if (deduplication) {\n        var printedServerQuery_1 = print(serverQuery);\n        var varJson_1 = canonicalStringify(variables);\n        var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);\n        observable = entry.observable;\n        if (!observable) {\n          var concast_1 = new Concast([execute(link, operation)]);\n          observable = entry.observable = concast_1;\n          concast_1.beforeNext(function cb(method, arg) {\n            if (method === \"next\" && \"hasNext\" in arg && arg.hasNext) {\n              concast_1.beforeNext(cb);\n            } else {\n              inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);\n            }\n          });\n        }\n      } else {\n        observable = new Concast([execute(link, operation)]);\n      }\n    } else {\n      observable = new Concast([Observable.of({\n        data: {}\n      })]);\n      context = this.prepareContext(context);\n    }\n    if (clientQuery) {\n      observable = asyncMap(observable, function (result) {\n        return _this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context: context,\n          variables: variables\n        });\n      });\n    }\n    return observable;\n  };\n  QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {\n    var requestId = queryInfo.lastRequestId = this.generateRequestId();\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    var linkDocument = this.cache.transformForLink(options.query);\n    return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function (result) {\n      var graphQLErrors = getGraphQLErrorsFromResult(result);\n      var hasErrors = graphQLErrors.length > 0;\n      var errorPolicy = options.errorPolicy;\n      // If we interrupted this request by calling getResultsFromLink again\n      // with the same QueryInfo object, we ignore the old results.\n      if (requestId >= queryInfo.lastRequestId) {\n        if (hasErrors && errorPolicy === \"none\") {\n          // Throwing here effectively calls observer.error.\n          throw queryInfo.markError(new ApolloError({\n            graphQLErrors: graphQLErrors\n          }));\n        }\n        // Use linkDocument rather than queryInfo.document so the\n        // operation/fragments used to write the result are the same as the\n        // ones used to obtain it from the link.\n        queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n        queryInfo.markReady();\n      }\n      var aqr = {\n        data: result.data,\n        loading: false,\n        networkStatus: NetworkStatus.ready\n      };\n      // In the case we start multiple network requests simulatenously, we\n      // want to ensure we properly set `data` if we're reporting on an old\n      // result which will not be caught by the conditional above that ends up\n      // throwing the markError result.\n      if (hasErrors && errorPolicy === \"none\") {\n        aqr.data = void 0;\n      }\n      if (hasErrors && errorPolicy !== \"ignore\") {\n        aqr.errors = graphQLErrors;\n        aqr.networkStatus = NetworkStatus.error;\n      }\n      return aqr;\n    }, function (networkError) {\n      var error = isApolloError(networkError) ? networkError : new ApolloError({\n        networkError: networkError\n      });\n      // Avoid storing errors from older interrupted queries.\n      if (requestId >= queryInfo.lastRequestId) {\n        queryInfo.markError(error);\n      }\n      throw error;\n    });\n  };\n  QueryManager.prototype.fetchConcastWithInfo = function (queryId, options,\n  // The initial networkStatus for this fetch, most often\n  // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n  // or setVariables.\n  networkStatus, query) {\n    var _this = this;\n    if (networkStatus === void 0) {\n      networkStatus = NetworkStatus.loading;\n    }\n    if (query === void 0) {\n      query = options.query;\n    }\n    var variables = this.getVariables(query, options.variables);\n    var queryInfo = this.getQuery(queryId);\n    var defaults = this.defaultOptions.watchQuery;\n    var _a = options.fetchPolicy,\n      fetchPolicy = _a === void 0 ? defaults && defaults.fetchPolicy || \"cache-first\" : _a,\n      _b = options.errorPolicy,\n      errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || \"none\" : _b,\n      _c = options.returnPartialData,\n      returnPartialData = _c === void 0 ? false : _c,\n      _d = options.notifyOnNetworkStatusChange,\n      notifyOnNetworkStatusChange = _d === void 0 ? false : _d,\n      _e = options.context,\n      context = _e === void 0 ? {} : _e;\n    var normalized = Object.assign({}, options, {\n      query: query,\n      variables: variables,\n      fetchPolicy: fetchPolicy,\n      errorPolicy: errorPolicy,\n      returnPartialData: returnPartialData,\n      notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n      context: context\n    });\n    var fromVariables = function (variables) {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n      var sourcesWithInfo = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n      if (\n      // If we're in standby, postpone advancing options.fetchPolicy using\n      // applyNextFetchPolicy.\n      normalized.fetchPolicy !== \"standby\" &&\n      // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n      // this is another way to detect when nothing was done/fetched.\n      sourcesWithInfo.sources.length > 0 && queryInfo.observableQuery) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n      }\n      return sourcesWithInfo;\n    };\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    var cleanupCancelFn = function () {\n      return _this.fetchCancelFns.delete(queryId);\n    };\n    this.fetchCancelFns.set(queryId, function (reason) {\n      cleanupCancelFn();\n      // This delay ensures the concast variable has been initialized.\n      setTimeout(function () {\n        return concast.cancel(reason);\n      });\n    });\n    var concast, containsDataFromLink;\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      concast = new Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function (sourcesWithInfo) {\n        return sourcesWithInfo.sources;\n      }));\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      var sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n    return {\n      concast: concast,\n      fromLink: containsDataFromLink\n    };\n  };\n  QueryManager.prototype.refetchQueries = function (_a) {\n    var _this = this;\n    var updateCache = _a.updateCache,\n      include = _a.include,\n      _b = _a.optimistic,\n      optimistic = _b === void 0 ? false : _b,\n      _c = _a.removeOptimistic,\n      removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId(\"refetchQueries\") : void 0 : _c,\n      onQueryUpdated = _a.onQueryUpdated;\n    var includedQueriesById = new Map();\n    if (include) {\n      this.getObservableQueries(include).forEach(function (oq, queryId) {\n        includedQueriesById.set(queryId, {\n          oq: oq,\n          lastDiff: _this.getQuery(queryId).getDiff()\n        });\n      });\n    }\n    var results = new Map();\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: optimistic && removeOptimistic || false,\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic: removeOptimistic,\n        onWatchUpdated: function (watch, diff, lastDiff) {\n          var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n              var result = onQueryUpdated(oq, diff, lastDiff);\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              }\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(oq, result);\n              }\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, {\n                oq: oq,\n                lastDiff: lastDiff,\n                diff: diff\n              });\n            }\n          }\n        }\n      });\n    }\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(function (_a, queryId) {\n        var oq = _a.oq,\n          lastDiff = _a.lastDiff,\n          diff = _a.diff;\n        var result;\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            var info = oq[\"queryInfo\"];\n            info.reset(); // Force info.getDiff() to read from cache.\n            diff = info.getDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n        if (result !== false) {\n          results.set(oq, result);\n        }\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          _this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n    return results;\n  };\n  QueryManager.prototype.maskOperation = function (options) {\n    var _a, _b, _c;\n    var document = options.document,\n      data = options.data;\n    if (globalThis.__DEV__ !== false) {\n      var fetchPolicy = options.fetchPolicy,\n        id = options.id;\n      var operationType = (_a = getOperationDefinition(document)) === null || _a === void 0 ? void 0 : _a.operation;\n      var operationId = ((_b = operationType === null || operationType === void 0 ? void 0 : operationType[0]) !== null && _b !== void 0 ? _b : \"o\") + id;\n      if (this.dataMasking && fetchPolicy === \"no-cache\" && !isFullyUnmaskedOperation(document) && !this.noCacheWarningsByQueryId.has(operationId)) {\n        this.noCacheWarningsByQueryId.add(operationId);\n        globalThis.__DEV__ !== false && invariant.warn(37, (_c = getOperationName(document)) !== null && _c !== void 0 ? _c : \"Unnamed \".concat(operationType !== null && operationType !== void 0 ? operationType : \"operation\"));\n      }\n    }\n    return this.dataMasking ? maskOperation(data, document, this.cache) : data;\n  };\n  QueryManager.prototype.maskFragment = function (options) {\n    var data = options.data,\n      fragment = options.fragment,\n      fragmentName = options.fragmentName;\n    return this.dataMasking ? maskFragment(data, fragment, this.cache, fragmentName) : data;\n  };\n  QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a,\n  // The initial networkStatus for this fetch, most often\n  // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n  // or setVariables.\n  networkStatus) {\n    var _this = this;\n    var query = _a.query,\n      variables = _a.variables,\n      fetchPolicy = _a.fetchPolicy,\n      refetchWritePolicy = _a.refetchWritePolicy,\n      errorPolicy = _a.errorPolicy,\n      returnPartialData = _a.returnPartialData,\n      context = _a.context,\n      notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n    var oldNetworkStatus = queryInfo.networkStatus;\n    queryInfo.init({\n      document: query,\n      variables: variables,\n      networkStatus: networkStatus\n    });\n    var readCache = function () {\n      return queryInfo.getDiff();\n    };\n    var resultsFromCache = function (diff, networkStatus) {\n      if (networkStatus === void 0) {\n        networkStatus = queryInfo.networkStatus || NetworkStatus.loading;\n      }\n      var data = diff.result;\n      if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n      var fromData = function (data) {\n        return Observable.of(__assign({\n          data: data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus: networkStatus\n        }, diff.complete ? null : {\n          partial: true\n        }));\n      };\n      if (data && _this.getDocumentInfo(query).hasForcedResolvers) {\n        return _this.localState.runResolvers({\n          document: query,\n          remoteResult: {\n            data: data\n          },\n          context: context,\n          variables: variables,\n          onlyRunForcedResolvers: true\n        }).then(function (resolved) {\n          return fromData(resolved.data || void 0);\n        });\n      }\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (errorPolicy === \"none\" && networkStatus === NetworkStatus.refetch && Array.isArray(diff.missing)) {\n        return fromData(void 0);\n      }\n      return fromData(data);\n    };\n    var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */\n    // Watched queries must opt into overwriting existing data on refetch,\n    // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n    : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== \"merge\" ? 1 /* CacheWriteBehavior.OVERWRITE */ : 2 /* CacheWriteBehavior.MERGE */;\n    var resultsFromLink = function () {\n      return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n        query: query,\n        variables: variables,\n        context: context,\n        fetchPolicy: fetchPolicy,\n        errorPolicy: errorPolicy\n      });\n    };\n    var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === \"number\" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\":\n        {\n          var diff = readCache();\n          if (diff.complete) {\n            return {\n              fromLink: false,\n              sources: [resultsFromCache(diff, queryInfo.markReady())]\n            };\n          }\n          if (returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n          return {\n            fromLink: true,\n            sources: [resultsFromLink()]\n          };\n        }\n      case \"cache-and-network\":\n        {\n          var diff = readCache();\n          if (diff.complete || returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n          return {\n            fromLink: true,\n            sources: [resultsFromLink()]\n          };\n        }\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          sources: [resultsFromCache(readCache(), queryInfo.markReady())]\n        };\n      case \"network-only\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(readCache()), resultsFromLink()]\n          };\n        }\n        return {\n          fromLink: true,\n          sources: [resultsFromLink()]\n        };\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            // Note that queryInfo.getDiff() for no-cache queries does not call\n            // cache.diff, but instead returns a { complete: false } stub result\n            // when there is no queryInfo.diff already defined.\n            sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]\n          };\n        }\n        return {\n          fromLink: true,\n          sources: [resultsFromLink()]\n        };\n      case \"standby\":\n        return {\n          fromLink: false,\n          sources: []\n        };\n    }\n  };\n  QueryManager.prototype.getQuery = function (queryId) {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId);\n  };\n  QueryManager.prototype.prepareContext = function (context) {\n    if (context === void 0) {\n      context = {};\n    }\n    var newContext = this.localState.prepareContext(context);\n    return __assign(__assign(__assign({}, this.defaultContext), newContext), {\n      clientAwareness: this.clientAwareness\n    });\n  };\n  return QueryManager;\n}();\nexport { QueryManager };\n", "import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\nimport { argumentsObjectFromField, buildQueryFromSelectionSet, createFragmentMap, getFragmentDefinitions, getMainDefinition, hasDirectives, isField, isInlineFragment, mergeDeep, mergeDeepArray, removeClientSetsFromDocument, resultKeyNameFromField, shouldInclude } from \"../utilities/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\nvar LocalState = /** @class */function () {\n  function LocalState(_a) {\n    var cache = _a.cache,\n      client = _a.client,\n      resolvers = _a.resolvers,\n      fragmentMatcher = _a.fragmentMatcher;\n    this.selectionsToResolveCache = new WeakMap();\n    this.cache = cache;\n    if (client) {\n      this.client = client;\n    }\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n  LocalState.prototype.addResolvers = function (resolvers) {\n    var _this = this;\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(function (resolverGroup) {\n        _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  };\n  LocalState.prototype.setResolvers = function (resolvers) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  };\n  LocalState.prototype.getResolvers = function () {\n    return this.resolvers || {};\n  };\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  LocalState.prototype.runResolvers = function (_a) {\n    return __awaiter(this, arguments, void 0, function (_b) {\n      var document = _b.document,\n        remoteResult = _b.remoteResult,\n        context = _b.context,\n        variables = _b.variables,\n        _c = _b.onlyRunForcedResolvers,\n        onlyRunForcedResolvers = _c === void 0 ? false : _c;\n      return __generator(this, function (_d) {\n        if (document) {\n          return [2 /*return*/, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) {\n            return __assign(__assign({}, remoteResult), {\n              data: localResult.result\n            });\n          })];\n        }\n        return [2 /*return*/, remoteResult];\n      });\n    });\n  };\n  LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  };\n  LocalState.prototype.getFragmentMatcher = function () {\n    return this.fragmentMatcher;\n  };\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  LocalState.prototype.clientQuery = function (document) {\n    if (hasDirectives([\"client\"], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n    return null;\n  };\n  // Server queries are stripped of all @client based selection sets.\n  LocalState.prototype.serverQuery = function (document) {\n    return removeClientSetsFromDocument(document);\n  };\n  LocalState.prototype.prepareContext = function (context) {\n    var cache = this.cache;\n    return __assign(__assign({}, context), {\n      cache: cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey: function (obj) {\n        return cache.identify(obj);\n      }\n    });\n  };\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  LocalState.prototype.addExportedVariables = function (document_1) {\n    return __awaiter(this, arguments, void 0, function (document, variables, context) {\n      if (variables === void 0) {\n        variables = {};\n      }\n      if (context === void 0) {\n        context = {};\n      }\n      return __generator(this, function (_a) {\n        if (document) {\n          return [2 /*return*/, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) {\n            return __assign(__assign({}, variables), data.exportedVariables);\n          })];\n        }\n        return [2 /*return*/, __assign({}, variables)];\n      });\n    });\n  };\n  LocalState.prototype.shouldForceResolvers = function (document) {\n    var forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter: function (node) {\n          if (node.name.value === \"client\" && node.arguments) {\n            forceResolvers = node.arguments.some(function (arg) {\n              return arg.name.value === \"always\" && arg.value.kind === \"BooleanValue\" && arg.value.value === true;\n            });\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        }\n      }\n    });\n    return forceResolvers;\n  };\n  // Query the cache and return matching data.\n  LocalState.prototype.buildRootValueFromCache = function (document, variables) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables: variables,\n      returnPartialData: true,\n      optimistic: false\n    }).result;\n  };\n  LocalState.prototype.resolveDocument = function (document_1, rootValue_1) {\n    return __awaiter(this, arguments, void 0, function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\n      var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a, cache, client, execContext, isClientFieldDescendant;\n      if (context === void 0) {\n        context = {};\n      }\n      if (variables === void 0) {\n        variables = {};\n      }\n      if (fragmentMatcher === void 0) {\n        fragmentMatcher = function () {\n          return true;\n        };\n      }\n      if (onlyRunForcedResolvers === void 0) {\n        onlyRunForcedResolvers = false;\n      }\n      return __generator(this, function (_b) {\n        mainDefinition = getMainDefinition(document);\n        fragments = getFragmentDefinitions(document);\n        fragmentMap = createFragmentMap(fragments);\n        selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);\n        definitionOperation = mainDefinition.operation;\n        defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : \"Query\";\n        _a = this, cache = _a.cache, client = _a.client;\n        execContext = {\n          fragmentMap: fragmentMap,\n          context: __assign(__assign({}, context), {\n            cache: cache,\n            client: client\n          }),\n          variables: variables,\n          fragmentMatcher: fragmentMatcher,\n          defaultOperationType: defaultOperationType,\n          exportedVariables: {},\n          selectionsToResolve: selectionsToResolve,\n          onlyRunForcedResolvers: onlyRunForcedResolvers\n        };\n        isClientFieldDescendant = false;\n        return [2 /*return*/, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (result) {\n          return {\n            result: result,\n            exportedVariables: execContext.exportedVariables\n          };\n        })];\n      });\n    });\n  };\n  LocalState.prototype.resolveSelectionSet = function (selectionSet, isClientFieldDescendant, rootValue, execContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fragmentMap, context, variables, resultsToMerge, execute;\n      var _this = this;\n      return __generator(this, function (_a) {\n        fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\n        resultsToMerge = [rootValue];\n        execute = function (selection) {\n          return __awaiter(_this, void 0, void 0, function () {\n            var fragment, typeCondition;\n            return __generator(this, function (_a) {\n              if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {\n                // Skip selections without @client directives\n                // (still processing if one of the ancestors or one of the child fields has @client directive)\n                return [2 /*return*/];\n              }\n              if (!shouldInclude(selection, variables)) {\n                // Skip this entirely.\n                return [2 /*return*/];\n              }\n              if (isField(selection)) {\n                return [2 /*return*/, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function (fieldResult) {\n                  var _a;\n                  if (typeof fieldResult !== \"undefined\") {\n                    resultsToMerge.push((_a = {}, _a[resultKeyNameFromField(selection)] = fieldResult, _a));\n                  }\n                })];\n              }\n              if (isInlineFragment(selection)) {\n                fragment = selection;\n              } else {\n                // This is a named fragment.\n                fragment = fragmentMap[selection.name.value];\n                invariant(fragment, 19, selection.name.value);\n              }\n              if (fragment && fragment.typeCondition) {\n                typeCondition = fragment.typeCondition.name.value;\n                if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n                  return [2 /*return*/, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (fragmentResult) {\n                    resultsToMerge.push(fragmentResult);\n                  })];\n                }\n              }\n              return [2 /*return*/];\n            });\n          });\n        };\n        return [2 /*return*/, Promise.all(selectionSet.selections.map(execute)).then(function () {\n          return mergeDeepArray(resultsToMerge);\n        })];\n      });\n    });\n  };\n  LocalState.prototype.resolveField = function (field, isClientFieldDescendant, rootValue, execContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\n      var _this = this;\n      return __generator(this, function (_a) {\n        if (!rootValue) {\n          return [2 /*return*/, null];\n        }\n        variables = execContext.variables;\n        fieldName = field.name.value;\n        aliasedFieldName = resultKeyNameFromField(field);\n        aliasUsed = fieldName !== aliasedFieldName;\n        defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n        resultPromise = Promise.resolve(defaultResult);\n        // Usually all local resolvers are run when passing through here, but\n        // if we've specifically identified that we only want to run forced\n        // resolvers (that is, resolvers for fields marked with\n        // `@client(always: true)`), then we'll skip running non-forced resolvers.\n        if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {\n          resolverType = rootValue.__typename || execContext.defaultOperationType;\n          resolverMap = this.resolvers && this.resolvers[resolverType];\n          if (resolverMap) {\n            resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n            if (resolve) {\n              resultPromise = Promise.resolve(\n              // In case the resolve function accesses reactive variables,\n              // set cacheSlot to the current cache instance.\n              cacheSlot.withValue(this.cache, resolve, [rootValue, argumentsObjectFromField(field, variables), execContext.context, {\n                field: field,\n                fragmentMap: execContext.fragmentMap\n              }]));\n            }\n          }\n        }\n        return [2 /*return*/, resultPromise.then(function (result) {\n          var _a, _b;\n          if (result === void 0) {\n            result = defaultResult;\n          }\n          // If an @export directive is associated with the current field, store\n          // the `as` export variable name and current result for later use.\n          if (field.directives) {\n            field.directives.forEach(function (directive) {\n              if (directive.name.value === \"export\" && directive.arguments) {\n                directive.arguments.forEach(function (arg) {\n                  if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                    execContext.exportedVariables[arg.value.value] = result;\n                  }\n                });\n              }\n            });\n          }\n          // Handle all scalar types here.\n          if (!field.selectionSet) {\n            return result;\n          }\n          // From here down, the field has a selection set, which means it's trying\n          // to query a GraphQLObjectType.\n          if (result == null) {\n            // Basically any field in a GraphQL response can be null, or missing\n            return result;\n          }\n          var isClientField = (_b = (_a = field.directives) === null || _a === void 0 ? void 0 : _a.some(function (d) {\n            return d.name.value === \"client\";\n          })) !== null && _b !== void 0 ? _b : false;\n          if (Array.isArray(result)) {\n            return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);\n          }\n          // Returned value is an object, and the query has a sub-selection. Recurse.\n          if (field.selectionSet) {\n            return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);\n          }\n        })];\n      });\n    });\n  };\n  LocalState.prototype.resolveSubSelectedArray = function (field, isClientFieldDescendant, result, execContext) {\n    var _this = this;\n    return Promise.all(result.map(function (item) {\n      if (item === null) {\n        return null;\n      }\n      // This is a nested array, recurse.\n      if (Array.isArray(item)) {\n        return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);\n      }\n      // This is an object, run the selection set on it.\n      if (field.selectionSet) {\n        return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);\n      }\n    }));\n  };\n  // Collect selection nodes on paths from document root down to all @client directives.\n  // This function takes into account transitive fragment spreads.\n  // Complexity equals to a single `visit` over the full document.\n  LocalState.prototype.collectSelectionsToResolve = function (mainDefinition, fragmentMap) {\n    var isSingleASTNode = function (node) {\n      return !Array.isArray(node);\n    };\n    var selectionsToResolveCache = this.selectionsToResolveCache;\n    function collectByDefinition(definitionNode) {\n      if (!selectionsToResolveCache.has(definitionNode)) {\n        var matches_1 = new Set();\n        selectionsToResolveCache.set(definitionNode, matches_1);\n        visit(definitionNode, {\n          Directive: function (node, _, __, ___, ancestors) {\n            if (node.name.value === \"client\") {\n              ancestors.forEach(function (node) {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches_1.add(node);\n                }\n              });\n            }\n          },\n          FragmentSpread: function (spread, _, __, ___, ancestors) {\n            var fragment = fragmentMap[spread.name.value];\n            invariant(fragment, 20, spread.name.value);\n            var fragmentSelections = collectByDefinition(fragment);\n            if (fragmentSelections.size > 0) {\n              // Fragment for this spread contains @client directive (either directly or transitively)\n              // Collect selection nodes on paths from the root down to fields with the @client directive\n              ancestors.forEach(function (node) {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches_1.add(node);\n                }\n              });\n              matches_1.add(spread);\n              fragmentSelections.forEach(function (selection) {\n                matches_1.add(selection);\n              });\n            }\n          }\n        });\n      }\n      return selectionsToResolveCache.get(definitionNode);\n    }\n    return collectByDefinition(mainDefinition);\n  };\n  return LocalState;\n}();\nexport { LocalState };\n", "import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport { version } from \"../version.js\";\nimport { HttpLink } from \"../link/http/index.js\";\nimport { QueryManager } from \"./QueryManager.js\";\nimport { LocalState } from \"./LocalState.js\";\nvar hasSuggestedDevtools = false;\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\nimport { mergeOptions } from \"../utilities/index.js\";\nimport { getApolloClientMemoryInternals } from \"../utilities/caching/getMemoryInternals.js\";\nexport { mergeOptions };\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an `ApolloLink` instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through `Observable` instances.\n */\nvar ApolloClient = /** @class */function () {\n  /**\n   * Constructs an instance of `ApolloClient`.\n   *\n   * @example\n   * ```js\n   * import { ApolloClient, InMemoryCache } from '@apollo/client';\n   *\n   * const cache = new InMemoryCache();\n   *\n   * const client = new ApolloClient({\n   *   // Provide required constructor fields\n   *   cache: cache,\n   *   uri: 'http://localhost:4000/',\n   *\n   *   // Provide some optional constructor fields\n   *   name: 'react-web-client',\n   *   version: '1.3',\n   *   queryDeduplication: false,\n   *   defaultOptions: {\n   *     watchQuery: {\n   *       fetchPolicy: 'cache-and-network',\n   *     },\n   *   },\n   * });\n   * ```\n   */\n  function ApolloClient(options) {\n    var _this = this;\n    var _a;\n    this.resetStoreCallbacks = [];\n    this.clearStoreCallbacks = [];\n    if (!options.cache) {\n      throw newInvariantError(16);\n    }\n    var uri = options.uri,\n      credentials = options.credentials,\n      headers = options.headers,\n      cache = options.cache,\n      documentTransform = options.documentTransform,\n      _b = options.ssrMode,\n      ssrMode = _b === void 0 ? false : _b,\n      _c = options.ssrForceFetchDelay,\n      ssrForceFetchDelay = _c === void 0 ? 0 : _c,\n      // Expose the client instance as window.__APOLLO_CLIENT__ and call\n      // onBroadcast in queryManager.broadcastQueries to enable browser\n      // devtools, but disable them by default in production.\n      connectToDevTools = options.connectToDevTools,\n      _d = options.queryDeduplication,\n      queryDeduplication = _d === void 0 ? true : _d,\n      defaultOptions = options.defaultOptions,\n      defaultContext = options.defaultContext,\n      _e = options.assumeImmutableResults,\n      assumeImmutableResults = _e === void 0 ? cache.assumeImmutableResults : _e,\n      resolvers = options.resolvers,\n      typeDefs = options.typeDefs,\n      fragmentMatcher = options.fragmentMatcher,\n      clientAwarenessName = options.name,\n      clientAwarenessVersion = options.version,\n      devtools = options.devtools,\n      dataMasking = options.dataMasking;\n    var link = options.link;\n    if (!link) {\n      link = uri ? new HttpLink({\n        uri: uri,\n        credentials: credentials,\n        headers: headers\n      }) : ApolloLink.empty();\n    }\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.typeDefs = typeDefs;\n    this.devtoolsConfig = __assign(__assign({}, devtools), {\n      enabled: (_a = devtools === null || devtools === void 0 ? void 0 : devtools.enabled) !== null && _a !== void 0 ? _a : connectToDevTools\n    });\n    if (this.devtoolsConfig.enabled === undefined) {\n      this.devtoolsConfig.enabled = globalThis.__DEV__ !== false;\n    }\n    if (ssrForceFetchDelay) {\n      setTimeout(function () {\n        return _this.disableNetworkFetches = false;\n      }, ssrForceFetchDelay);\n    }\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.watchFragment = this.watchFragment.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n    this.version = version;\n    this.localState = new LocalState({\n      cache: cache,\n      client: this,\n      resolvers: resolvers,\n      fragmentMatcher: fragmentMatcher\n    });\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      defaultOptions: this.defaultOptions,\n      defaultContext: defaultContext,\n      documentTransform: documentTransform,\n      queryDeduplication: queryDeduplication,\n      ssrMode: ssrMode,\n      dataMasking: !!dataMasking,\n      clientAwareness: {\n        name: clientAwarenessName,\n        version: clientAwarenessVersion\n      },\n      localState: this.localState,\n      assumeImmutableResults: assumeImmutableResults,\n      onBroadcast: this.devtoolsConfig.enabled ? function () {\n        if (_this.devToolsHookCb) {\n          _this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: _this.queryManager.getQueryStore(),\n              mutations: _this.queryManager.mutationStore || {}\n            },\n            dataWithOptimisticResults: _this.cache.extract(true)\n          });\n        }\n      } : void 0\n    });\n    if (this.devtoolsConfig.enabled) this.connectToDevTools();\n  }\n  ApolloClient.prototype.connectToDevTools = function () {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n    var windowWithDevTools = window;\n    var devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n    (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);\n    windowWithDevTools.__APOLLO_CLIENT__ = this;\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {\n      hasSuggestedDevtools = true;\n      if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {\n        setTimeout(function () {\n          if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n            var nav = window.navigator;\n            var ua = nav && nav.userAgent;\n            var url = void 0;\n            if (typeof ua === \"string\") {\n              if (ua.indexOf(\"Chrome/\") > -1) {\n                url = \"https://chrome.google.com/webstore/detail/\" + \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n              } else if (ua.indexOf(\"Firefox/\") > -1) {\n                url = \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n              }\n            }\n            if (url) {\n              globalThis.__DEV__ !== false && invariant.log(\"Download the Apollo DevTools for a better development \" + \"experience: %s\", url);\n            }\n          }\n        }, 10000);\n      }\n    }\n  };\n  Object.defineProperty(ApolloClient.prototype, \"documentTransform\", {\n    /**\n     * The `DocumentTransform` used to modify GraphQL documents before a request\n     * is made. If a custom `DocumentTransform` is not provided, this will be the\n     * default document transform.\n     */\n    get: function () {\n      return this.queryManager.documentTransform;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  ApolloClient.prototype.stop = function () {\n    this.queryManager.stop();\n  };\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an `ObservableQuery`. We can subscribe to this `ObservableQuery` and\n   * receive updated results through an observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  ApolloClient.prototype.watchQuery = function (options) {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (this.disableNetworkFetches && (options.fetchPolicy === \"network-only\" || options.fetchPolicy === \"cache-and-network\")) {\n      options = __assign(__assign({}, options), {\n        fetchPolicy: \"cache-first\"\n      });\n    }\n    return this.queryManager.watchQuery(options);\n  };\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a `Promise` which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options - An object of type `QueryOptions` that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  ApolloClient.prototype.query = function (options) {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n    invariant(options.fetchPolicy !== \"cache-and-network\", 17);\n    if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n      options = __assign(__assign({}, options), {\n        fetchPolicy: \"cache-first\"\n      });\n    }\n    return this.queryManager.query(options);\n  };\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * Promise which is either resolved with the resulting data or rejected with an\n   * error. In some cases both `data` and `errors` might be undefined, for example\n   * when `errorPolicy` is set to `'ignore'`.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  ApolloClient.prototype.mutate = function (options) {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n    return this.queryManager.mutate(options);\n  };\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * `Observable` which either emits received data or an error.\n   */\n  ApolloClient.prototype.subscribe = function (options) {\n    var _this = this;\n    var id = this.queryManager.generateQueryId();\n    return this.queryManager.startGraphQLSubscription(options).map(function (result) {\n      return __assign(__assign({}, result), {\n        data: _this.queryManager.maskOperation({\n          document: options.query,\n          data: result.data,\n          fetchPolicy: options.fetchPolicy,\n          id: id\n        })\n      });\n    });\n  };\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic - Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  ApolloClient.prototype.readQuery = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n    return this.cache.readQuery(options, optimistic);\n  };\n  /**\n   * Watches the cache store of the fragment according to the options specified\n   * and returns an `Observable`. We can subscribe to this\n   * `Observable` and receive updated results through an\n   * observer when the cache store changes.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @since 3.10.0\n   * @param options - An object of type `WatchFragmentOptions` that allows\n   * the cache to identify the fragment and optionally specify whether to react\n   * to optimistic updates.\n   */\n  ApolloClient.prototype.watchFragment = function (options) {\n    var _a;\n    return this.cache.watchFragment(__assign(__assign({}, options), (_a = {}, _a[Symbol.for(\"apollo.dataMasking\")] = this.queryManager.dataMasking, _a)));\n  };\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic - Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  ApolloClient.prototype.readFragment = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n    return this.cache.readFragment(options, optimistic);\n  };\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  ApolloClient.prototype.writeQuery = function (options) {\n    var ref = this.cache.writeQuery(options);\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n    return ref;\n  };\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  ApolloClient.prototype.writeFragment = function (options) {\n    var ref = this.cache.writeFragment(options);\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n    return ref;\n  };\n  ApolloClient.prototype.__actionHookForDevTools = function (cb) {\n    this.devToolsHookCb = cb;\n  };\n  ApolloClient.prototype.__requestRaw = function (payload) {\n    return execute(this.link, payload);\n  };\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  ApolloClient.prototype.resetStore = function () {\n    var _this = this;\n    return Promise.resolve().then(function () {\n      return _this.queryManager.clearStore({\n        discardWatches: false\n      });\n    }).then(function () {\n      return Promise.all(_this.resetStoreCallbacks.map(function (fn) {\n        return fn();\n      }));\n    }).then(function () {\n      return _this.reFetchObservableQueries();\n    });\n  };\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  ApolloClient.prototype.clearStore = function () {\n    var _this = this;\n    return Promise.resolve().then(function () {\n      return _this.queryManager.clearStore({\n        discardWatches: true\n      });\n    }).then(function () {\n      return Promise.all(_this.clearStoreCallbacks.map(function (fn) {\n        return fn();\n      }));\n    });\n  };\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  ApolloClient.prototype.onResetStore = function (cb) {\n    var _this = this;\n    this.resetStoreCallbacks.push(cb);\n    return function () {\n      _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) {\n        return c !== cb;\n      });\n    };\n  };\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  ApolloClient.prototype.onClearStore = function (cb) {\n    var _this = this;\n    this.clearStoreCallbacks.push(cb);\n    return function () {\n      _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) {\n        return c !== cb;\n      });\n    };\n  };\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  };\n  /**\n   * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` *will* refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  ApolloClient.prototype.refetchQueries = function (options) {\n    var map = this.queryManager.refetchQueries(options);\n    var queries = [];\n    var results = [];\n    map.forEach(function (result, obsQuery) {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n    var result = Promise.all(results);\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch(function (error) {\n      globalThis.__DEV__ !== false && invariant.debug(18, error);\n    });\n    return result;\n  };\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n   * query ID strings.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   */\n  ApolloClient.prototype.getObservableQueries = function (include) {\n    if (include === void 0) {\n      include = \"active\";\n    }\n    return this.queryManager.getObservableQueries(include);\n  };\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  ApolloClient.prototype.extract = function (optimistic) {\n    return this.cache.extract(optimistic);\n  };\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  ApolloClient.prototype.restore = function (serializedState) {\n    return this.cache.restore(serializedState);\n  };\n  /**\n   * Add additional local resolvers.\n   */\n  ApolloClient.prototype.addResolvers = function (resolvers) {\n    this.localState.addResolvers(resolvers);\n  };\n  /**\n   * Set (override existing) local resolvers.\n   */\n  ApolloClient.prototype.setResolvers = function (resolvers) {\n    this.localState.setResolvers(resolvers);\n  };\n  /**\n   * Get all registered local resolvers.\n   */\n  ApolloClient.prototype.getResolvers = function () {\n    return this.localState.getResolvers();\n  };\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  };\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  ApolloClient.prototype.setLink = function (newLink) {\n    this.link = this.queryManager.link = newLink;\n  };\n  Object.defineProperty(ApolloClient.prototype, \"defaultContext\", {\n    get: function () {\n      return this.queryManager.defaultContext;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return ApolloClient;\n}();\nexport { ApolloClient };\nif (globalThis.__DEV__ !== false) {\n  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\n}\n", "import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n  var seenKeys = new Set();\n  var definitions = [];\n  ast.definitions.forEach(function (fragmentDefinition) {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n      var sourceKeySet = fragmentSourceMap.get(fragmentName);\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\" + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\" + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set());\n      }\n      sourceKeySet.add(sourceKey);\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n  return __assign(__assign({}, ast), {\n    definitions: definitions\n  });\n}\nfunction stripLoc(doc) {\n  var workSet = new Set(doc.definitions);\n  workSet.forEach(function (node) {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(function (key) {\n      var value = node[key];\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n  var loc = doc.loc;\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n  return doc;\n}\nfunction parseDocument(source) {\n  var cacheKey = normalize(source);\n  if (!docCache.has(cacheKey)) {\n    var parsed = parse(source, {\n      experimentalFragmentVariables: experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables\n    });\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n    docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n  }\n  return docCache.get(cacheKey);\n}\nexport function gql(literals) {\n  var args = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n  var result = literals[0];\n  args.forEach(function (arg, i) {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n    result += literals[i + 1];\n  });\n  return parseDocument(result);\n}\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\nvar extras = {\n  gql: gql,\n  resetCaches: resetCaches,\n  disableFragmentWarnings: disableFragmentWarnings,\n  enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n(function (gql_1) {\n  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nexport default gql;\n", "/* Core */\nexport { ApolloClient, mergeOptions } from \"./ApolloClient.js\";\nexport { ObservableQuery } from \"./ObservableQuery.js\";\nexport { NetworkStatus, isNetworkRequestSettled } from \"./networkStatus.js\";\nexport { isApolloError, ApolloError } from \"../errors/index.js\";\nexport { Cache, ApolloCache, InMemoryCache, MissingFieldError, defaultDataIdFromObject, makeVar } from \"../cache/index.js\";\n/* Link */\nexport * from \"../link/core/index.js\";\nexport * from \"../link/http/index.js\";\nexport { fromError, toPromise, fromPromise, throwServerError } from \"../link/utils/index.js\";\nexport { DocumentTransform, Observable, isReference, makeReference } from \"../utilities/index.js\";\n/* Supporting */\n// The verbosity of invariant.{log,warn,error} can be controlled globally\n// (for anyone using the same ts-invariant package) by passing \"log\",\n// \"warn\", \"error\", or \"silent\" to setVerbosity (\"log\" is the default).\n// Note that all invariant.* logging is hidden in production.\nimport { setVerbosity } from \"ts-invariant\";\nexport { setVerbosity as setLogVerbosity };\nsetVerbosity(globalThis.__DEV__ !== false ? \"log\" : \"silent\");\n// Note that importing `gql` by itself, then destructuring\n// additional properties separately before exporting, is intentional.\n// Due to the way the `graphql-tag` library is setup, certain bundlers\n// can't find the properties added to the exported `gql` function without\n// additional guidance (e.g. Rollup - see\n// https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module).\n// Instead of having people that are using bundlers with `@apollo/client` add\n// extra bundler config to help `graphql-tag` exports be found (which would be\n// awkward since they aren't importing `graphql-tag` themselves), this\n// workaround of pulling the extra properties off the `gql` function,\n// then re-exporting them separately, helps keeps bundlers happy without any\n// additional config changes.\nexport { gql, resetCaches, disableFragmentWarnings, enableExperimentalFragmentVariables, disableExperimentalFragmentVariables } from \"graphql-tag\";\n"],
  "mappings": "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",
  "names": ["err", "ApolloError", "print", "_a", "version", "_b", "_c", "parseError", "HttpLink", "hasOwnProperty", "fragment", "ApolloCache", "Cache", "MissingFieldError", "EntityStore", "CacheGroup", "EntityStore", "Root", "Layer", "Stump", "ObjectCanon", "StoreReader", "result", "_a", "cache", "d", "Policies", "existing", "incoming", "supertypeSet", "StoreWriter", "_a", "dataId", "context", "value", "selectionSet", "InMemoryCache", "_a", "FragmentRegistry", "NetworkStatus", "hasOwnProperty", "ObservableQuery", "_a", "updateQuery", "info", "QueryInfo", "diff", "hasOwnProperty", "QueryManager", "hasClientExports", "cache", "diff", "DELETE", "result", "variables", "sourcesWithInfo", "_a", "networkStatus", "data", "LocalState", "execute", "_a", "node", "ApolloClient", "defaultOptions", "result", "normalize"]
}
